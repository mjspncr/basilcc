namespace basilcc
{
  class BasilCC;

  typedef class Strategy const * StrategyPtr;
  typedef std::vector <StrategyPtr> StrategyPtrVector;

  // add error recover strategy
  void addInsertStrategy (BasilCC & cc, SymbolPtr token, std::string const & lexeme = std::string ())
  {
    cc.getTable <StrategyTable> ().addInsertStrategy (token, lexeme);
  }
  void addDeleteStrategy (BasilCC & cc, int num)
  {
    cc.getTable <StrategyTable> ().addDeleteStrategy (num);
  }

  // get error recover strategies
  StrategyPtrVector const & getStrategies (BasilCC & cc)
  {
    return cc.getTable <StrategyTable> ().getStrategies ();
  }
}

using namespace basilcc;
using namespace std;

namespace
{
  class StrategyTable : public Table
  {
  public:
    StrategyTable (BasilCC & basilcc)
    {}
    ~ StrategyTable ()
    {
      deleteObjects (m_strategies.begin (), m_strategies.end ());
    }
    // add strategy
    void addInsertStrategy (SymbolPtr token, std::string const & lexeme)
    {
      m_strategies.push_back (new InsertStrategy (token, lexeme));
    }
    void addDeleteStrategy (int num)
    {
      m_strategies.push_back (new DeleteStrategy (num));
    }
    StrategyPtrVector const & getStrategies () const
    {
      return m_strategies;
    }
    enum { TABLE = TABLE_STRATEGY }
  private:
    StrategyPtrVector m_strategies;
  }
}

#hdr
#include <basilcc/symbol_ptr.h>
#include <vector>
#include <string>
#end

#src
#include <basilcc/basilcc.h>
#include <basilcc/strategy.h>
#include <basilcc/table.h>
#include <basilcc/util.h>
#end
