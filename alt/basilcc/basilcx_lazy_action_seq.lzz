namespace basilcx {

class ActionSeq;
class LazyAction;
class Shift;
class Symbol;
class Workspace;
typedef std::vector<LazyAction *> LazyActionVector;
typedef std::vector<Shift> ShiftVector;

// lazy action sequence
class LazyActionSeq {
  public:
    // steals lazy actions
    LazyActionSeq(LazyActionVector &lazy_actions)
    {
        _lazy_actions.swap(lazy_actions);
    }

    ~LazyActionSeq()
    {}

    // get lazy actions
    inline LazyActionVector const &get_lazy_actions() const
    {
        return _lazy_actions;
    }

    // get action seq
    ActionSeq *get_action_seq(Workspace &w, ShiftVector const &token_shifts, Symbol *token) const
    {
        ActionVector actions;
        actions.reserve(_lazy_actions.size());
        for (LazyAction *lazy_action : _lazy_actions) {
            actions.push_back(lazy_action->get_action(w, token_shifts, token));
        }
        return w.action_seqs.get_action_seq(actions);
    }

    // true if actions all reductions (or if action seq can be the default)
    bool is_reduction() const
    {
        for (LazyAction *lazy_action : _lazy_actions) {
            if (lazy_action->is_shift()) {
                return false;
            }
        }
        return true;
    }

  private:
    LazyActionVector _lazy_actions;
};

// true if a < b
bool operator<(LazyActionSeq const &a, LazyActionSeq const &b)
{
    LazyActionVector const &a_lazy_actions = a.get_lazy_actions();
    LazyActionVector const &b_lazy_actions = b.get_lazy_actions();
    if (a_lazy_actions.size() != b_lazy_actions.size()) {
        return a_lazy_actions.size() < b_lazy_actions.size();
    }
    return a_lazy_actions < b_lazy_actions;
}

} // basilcx

#hdr
#include <map>
#include <vector>
#end

#src
#include <basilcx_lazy_action.h>
#include <basilcx_workspace.h>
#end
