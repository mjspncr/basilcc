// basilcc_rule_table
//
// maintains all rules
//

namespace basilcc {

class Node;
class Compiler;
class Symbol;
class Rule;

typedef std::vector<RuleSymbol> RuleSymbolVector;
typedef std::multimap<Symbol const *, Rule *> RuleMap;
typedef std::pair<RuleMap::const_iterator, RuleMap::const_iterator> RuleMapRange;

class RuleTable
{
  public:
    RuleTable(Compiler &c)
        : _c(c)
    {
        _enable_bypass = false; // TODO: read from config
    }

    ~RuleTable()
    {
        delete_values(_rules);
    }

    // add new rule
    Rule *add_rule(
        Node const *node,
        RuleSymbol const &left_rule_symbol,
        RuleSymbolVector const &right_rule_symbols,
        RuleSymbolVector const &explicit_follow,
        bool no_bypass
    )
    {
        Symbol const *left_symbol = left_rule_symbol.get_symbol();
        if (left_symbol->is_token()) {
            std::ostringstream ss;
            ss << "left hand symbol '" << left_symbol->get_name() << "' is a token";
            throw std::runtime_error(ss.str());
        }
        bool can_bypass = false;
        // can bypass rule on reduction if only one nonterminal on right hand side and no node
        if (_enable_bypass && !no_bypass && !node) {
            if (right_rule_symbols.size() == 1 && !right_rule_symbols.front().get_symbol()->is_token()) {
                can_bypass = true;
            }
        }
        return _rules.emplace_hint(_rules.end(), left_symbol,
            new Rule(_rules.size(), node, left_rule_symbol, right_rule_symbols, explicit_follow, can_bypass))->second;
    }

    // get all rules
    inline RuleMap const &get_rules() const
    {
        return _rules;
    }

    // get rules with left hand symbol
    RuleMapRange get_rules(Symbol const *left_symbol) const
    {
        return _rules.equal_range(left_symbol);
    }

    // true if left symbol
    bool is_left_symbol(Symbol const *symbol) const
    {
        return _rules.find(symbol) != _rules.end();
    }

    // freeze rules, check for errors
    void freeze_rules() const
    {
        // make sure at least one start rule
        if (!is_left_symbol(_c.get_start_symbol())) {
            throw std::runtime_error("missing at least one start rule");
        }
        // make sure each right hand nonterminal is defined
        for (RuleMap::value_type const &p: _rules) {
            Rule const *rule = p.second;
            for (RuleSymbol const &rule_symbol: rule->get_right_rule_symbols()) {
                Symbol const *symbol = rule_symbol.get_symbol();
                if (!symbol->is_token()) {
                    if (_c.is_start_symbol(symbol)) {
                        throw std::runtime_error("start symbol on right hand side of rule");
                    }
                    if (!is_left_symbol(symbol)) {
                        std::ostringstream ss;
                        ss << "nonterminal " << symbol->get_name() << " is not defined";
                        throw std::runtime_error(ss.str()); 
                    }
                }
            }
        }
    }

  private:
    Compiler &_c;
    bool _enable_bypass; // true if option to bypass rules is enabled
    RuleMap _rules; // rules indexed by left hand symbol
};

} // basilcc

#hdr
#include <basilcc_rule_symbol.h>
#include <vector>
#include <map>
#end

#src
#include <basilcc_compiler.h>
#include <basilcc_rule.h>
#include <basilcc_symbol.h>
#include <basilcc_util.h>
#include <sstream>
#end
