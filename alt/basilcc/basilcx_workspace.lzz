namespace basilcx {

class Action;
class ActionSeq;
class Move;

class Workspace {
  public:
    Workspace()
    {
        start_symbol = get_symbol("start");
        eot_symbol = get_symbol("EOT");
    }

    ~Workspace()
    {}

    // tables
    SymbolTable symbols;
    NodeTable nodes;
    RuleTable rules;
    BaseRuleTable base_rules;
    ShiftRuleTable shift_rules;
    FollowRuleTable follow_rules;
    BaseKernelTable base_kernels;
    ShiftKernelTable shift_kernels;
    FollowKernelTable follow_kernels;
    ActionTable actions;
    ActionSeqTable action_seqs;
    MoveTable moves;
    MoveSelTable move_sels;
    LazyActionTable lazy_actions;
    LazyActionSeqTable lazy_action_seqs;
    LazyMoveTable lazy_moves;
    LazyMoveSelTable lazy_move_sels;
    LazyFollowMoveTable lazy_follow_moves;
    ShiftSelTable shift_sels;
    StateMoveTable state_moves;
    StateTable states;
    // special symbols
    Symbol *start_symbol;
    Symbol *eot_symbol;

    // serialization options
    std::string usertype;
    std::string fsm_namespace;
    std::ostringstream usercode;

    // get symbol for name
    Symbol *get_symbol(std::string const &name)
    {
        return symbols.get_symbol(intern(name));
    }

    // add rule
    inline Rule *add_rule(
        Node *node,
        RuleSymbol const &left_rule_symbol,
        RuleSymbolVector const &right_rule_symbols,
        RuleSymbolVector const &explicit_follow,
        bool no_bypass
    )
    {
        return rules.add_rule(
            node,
            left_rule_symbol,
            right_rule_symbols,
            explicit_follow,
            left_rule_symbol.get_symbol() == start_symbol,
            no_bypass);
    }

    // no more rules
    void freeze_rules()
    {
        symbols.freeze();
        nodes.freeze();
        rules.freeze(*this);
    }

    // return true if symbol is a start symbol
    inline bool is_start_symbol(Symbol *symbol) const
    {
        return symbol == start_symbol;
    }

    // get start rules
    inline RuleMapRange get_start_rules() const
    {
        return rules.get_rules(start_symbol);
    }

    // get state from follow kernel
    inline State *get_state(FollowKernel *follow_kernel)
    {
        return states.get_state(*this, follow_kernel);
    }

    // create all states, return true if no conflicts, otherwise set number of conflicts and return false
    inline int create_states(int &num_conflicts, int &num_lex_state_conflicts)
    {
        return states.create_states(*this, num_conflicts, num_lex_state_conflicts);
    }

    // intern string, return shared char const *
    inline char const *intern(std::string const &str)
    {
      return strings.insert(str).first->c_str();
    }

  private:
    std::set<std::string> strings;
};

} // basilcx

#hdr
#include <basilcx_action_seq_table.h>
#include <basilcx_action_table.h>
#include <basilcx_base_kernel_table.h>
#include <basilcx_base_rule_table.h>
#include <basilcx_follow_kernel_table.h>
#include <basilcx_follow_rule_table.h>
#include <basilcx_lazy_action_seq_table.h>
#include <basilcx_lazy_action_table.h>
#include <basilcx_lazy_follow_move_table.h>
#include <basilcx_lazy_move_sel_table.h>
#include <basilcx_lazy_move_table.h>
#include <basilcx_move_sel_table.h>
#include <basilcx_move_table.h>
#include <basilcx_node_table.h>
#include <basilcx_rule_symbol.h>
#include <basilcx_rule_table.h>
#include <basilcx_shift_kernel_table.h>
#include <basilcx_shift_rule_table.h>
#include <basilcx_shift_sel_table.h>
#include <basilcx_state_move_table.h>
#include <basilcx_state_table.h>
#include <basilcx_symbol_table.h>
#include <sstream>
#end
