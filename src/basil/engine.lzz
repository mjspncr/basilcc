namespace basil
{
  // engine is a finite state machine with loaded app (with node and app metatables)
  class Engine : public FSM
  {
  public:
    Engine (lua_State * L, std::string const & fsm_filename, TokenNumberPtr token_numbers_beg, TokenNumberPtr token_numbers_end)
      : FSM (fsm_filename, token_numbers_beg, token_numbers_end), L (L), m_app_mt (LUA_NOREF)
    {}
    
    Engine (lua_State * L, std::string const & fsm_filename, TokenNumberPtr token_numbers_beg, TokenNumberPtr token_numbers_end,
        std::string const & app_filename)
      : FSM (fsm_filename, token_numbers_beg, token_numbers_end), L (L), m_app_mt (LUA_NOREF)
    {
      load (app_filename);
    }

    ~ Engine ()
    {
      // unref metatables
      luaL_unref (L, LUA_REGISTRYINDEX, m_app_mt);
      for (IntVectorConstIter i = m_node_mts.begin (), endi = m_node_mts.end (); i != endi; ++ i)
      {
        luaL_unref (L, LUA_REGISTRYINDEX, * i);
      }
    }

    // load app
    void load (std::string const & app_filename)
    {
      Loader (L, m_nodes, m_app_mt, m_node_mts).load (app_filename);
    }

    // create new app instance
    int newApp ()
    {
      if (m_app_mt == LUA_NOREF)
      {
        // no app created
        return LUA_NOREF;
      }
      // create app instance, set app_mt as metatable
      lua_newtable (L);
      lua_rawgeti (L, LUA_REGISTRYINDEX, m_app_mt);
      lua_setmetatable (L, -2);
      // save copy
      lua_pushvalue (L, -1);
      // call init function if exits
      lua_getfield (L, -1, "init");
      if (lua_isnil (L, -1))
      {
        lua_pop (L, 2);
      }
      else
      {
        // init function first then instance
        lua_rotate (L, -2, 1);
        // call it, don't expect any return argument
        if (lua_pcall (L, 1, 0, 1) != LUA_OK)
        {
          string errmsg = lua_tostring (L, -1);
          lua_pop (L, 1);
          throw runtime_error (errmsg);
        }
      }
      return luaL_ref (L, LUA_REGISTRYINDEX);
    }

    // get vector of keyword name and token number pairs
    StringIntVector const & getKeywords () const
    {
      return m_keywords;
    }

    // get lexical state at parser state
    inline int getLexState (int state_num) const
    {
      return m_states [state_num].lex_state;
    }

    // get rule
    inline FSM::Rule const & getRule (int rule) const
    {
      return m_rules [rule];
    }

    FSM::Rule const & getRule (int rule, int & node_mt) const
    {
      FSM::Rule const & fsm_rule = m_rules [rule];
      node_mt = fsm_rule.node == FSM::NOINDEX ? LUA_NOREF : m_node_mts [fsm_rule.node];
      return fsm_rule;
    }

    // get action seq at state on token
    FSM::ActionPtr getActionSeq (int state_num, int token, ActionPtr & action_seq_end) const
    {
      State const & state = m_states [state_num];
      MovePtr move_sel_beg = m_move_sels_beg [state.move_sel];
      MovePtr move_sel_end = m_move_sels_beg [state.move_sel + 1];
      Move const * t = lower_bound (move_sel_beg, move_sel_end, token, moveTokenLess);
      int action_seq_num = (t == move_sel_end || t->token != token) ? state.def_action_seq : t->action_seq;
      action_seq_end = m_action_seqs_beg [action_seq_num + 1];
      return m_action_seqs_beg [action_seq_num];
    }
    FSM::ActionPtrPair getActionSeq (int state_num, int token) const
    {
      State const & state = m_states [state_num];
      MovePtr move_sel_beg = m_move_sels_beg [state.move_sel];
      MovePtr move_sel_end = m_move_sels_beg [state.move_sel + 1];
      Move const * t = lower_bound (move_sel_beg, move_sel_end, token, moveTokenLess);
      int action_seq_num = (t == move_sel_end || t->token != token) ? state.def_action_seq : t->action_seq;
      ActionPtr action_seq_end = m_action_seqs_beg [action_seq_num + 1];
      ActionPtr action_seq_beg = m_action_seqs_beg [action_seq_num];
      return ActionPtrPair (action_seq_beg, action_seq_end);
    }

    // get goto state, npos if done
    int getGotoState (int state_num, int shortcut) const
    {
      Goto const & go2 = m_gotos [shortcut];
      if (go2.shift_state_sel == NOINDEX)
      {
        return NOINDEX;
      }
      ShiftStatePtr shift_state_sel_beg = m_shift_state_sels_beg [go2.shift_state_sel];
      ShiftStatePtr shift_state_sel_end = m_shift_state_sels_beg [go2.shift_state_sel + 1];
      int num = m_states [state_num].num;
      ShiftStatePtr t = lower_bound (shift_state_sel_beg, shift_state_sel_end, num, shiftStateNumLess);
      return (t == shift_state_sel_end || t->num != num) ? go2.def_state : t->state;
    }

    // get recover strategies
    FSM::StrategyPtrVector const & getRecoverStrategies () const
    {
      return m_strategies;
    }

    lua_State * const L;

  private:
    // true if token < move.token
    static inline bool moveTokenLess (Move const & move, int token)
    {
      return move.token < token;
    }
    // true if num < shift_sate.num
    static inline bool shiftStateNumLess (ShiftState const & shift_state, int num)
    {
      return shift_state.num < num;
    }

  private:
    // app metatable
    int m_app_mt;
    // node metatables
    IntVector m_node_mts;
  }
}

using namespace basil;
using namespace std;

namespace
{
  typedef std::vector <string> StringVector;
  typedef StringVector::const_iterator StringVectorConstIter;
  typedef IntVector::const_iterator IntVectorConstIter;

  class Loader
  {
  public:
    Loader (lua_State * L, StringVector const & nodes, int & app_mt, IntVector & node_mts)
      : L (L), m_nodes (nodes), m_app_mt (app_mt), m_node_mts (node_mts)
    {
      m_node_mts.resize (m_nodes.size (), LUA_NOREF);
    }
    ~ Loader ()
    {
      // unregister funcs
      for (luaL_Reg const * i = loader_funcs, * endi = ARRAY_END (loader_funcs); i != endi; ++ i)
      {
        lua_pushnil (L);
        lua_setglobal (L, i->name);
      }
    }
    // run loader, parse app filename, set node metatable array and return app metatable
    void load (string const & filename)
    {
      // register global loader functions with loader as upvalue
      for (luaL_Reg const * i = loader_funcs, * endi = ARRAY_END (loader_funcs); i != endi; ++ i)
      {
        lua_pushlightuserdata (L, this);
        lua_pushcclosure (L, i->func, 1);
        lua_setglobal (L, i->name);
      }
      // parse lua app
      if (luaL_dofile (L, filename.c_str ()))
      {
        string errmsg = lua_tostring (L, -1);
        lua_pop (L, 1);
        throw runtime_error (errmsg);
      }
      // make sure all nodes defined
      for (IntVectorConstIter i = m_node_mts.begin (), endi = m_node_mts.end (); i != endi; ++ i)
      {
        if (* i == LUA_NOREF)
        {
          throw runtime_error (Message ("node % not defined") << m_nodes [i - m_node_mts.begin ()]);
        }
      }
    }          
    // node callback  
    int onNode ()
    {
      char const * name = luaL_checkstring (L, 1);
      {
        try
        {
          // node names are sorted
          StringVectorConstIter i = lower_bound (m_nodes.begin (), m_nodes.end (), name);
          if (i == m_nodes.end () || * i != name)
          {
            throw runtime_error (Message ("% is not a valid node name") << name);
          }
          int & node_mt = m_node_mts [i - m_nodes.begin ()];
          if (node_mt != LUA_NOREF)
          {
            throw runtime_error (Message ("% is already defined") << name);
          }
          node_mt = pushMetatable ();
          return 1;
        }
        catch (exception const & e)
        {
          m_errmsg = e.what ();
        }
        catch (...)
        {
          m_errmsg = "unknown exception";
        }
      }
      return luaL_error (L, m_errmsg.c_str ());
    }
    // app callback
    int onApplication ()
    {
      {
        try
        {
          if (m_app_mt != LUA_NOREF)
          {
            throw runtime_error ("application already defined");
          }
          m_app_mt = pushMetatable ();
          return 1;
        }
        catch (exception const & e)
        {
          m_errmsg = e.what ();
        }
        catch (...)
        {
          m_errmsg = "unknown exception";
        }
      }
      return luaL_error (L, m_errmsg.c_str ());
    }

  private:
    // create metatable, save in registry and return ref, leave copy on stack
    int pushMetatable ()
    {
      lua_newtable (L);
      lua_pushvalue (L, -1);
      lua_setfield (L, -2, "__index");
      lua_pushvalue (L, -1);
      return luaL_ref (L, LUA_REGISTRYINDEX);
    }
  private:
    lua_State * L;
    // sorted node names 
    StringVector const & m_nodes;
    // app metatable
    int & m_app_mt;
    // node metatables indexed by node
    IntVector & m_node_mts;
    // buffer for lua error message
    string m_errmsg;
  }
  // loader functions
  int on_node (lua_State * L)
  {
    return ((Loader *) lua_touserdata (L, lua_upvalueindex (1)))->onNode ();
  }    
  int on_application (lua_State * L)
  {
    return ((Loader *) lua_touserdata (L, lua_upvalueindex (1)))->onApplication ();
  }
  luaL_Reg loader_funcs [] =
  {
    { "node", on_node },
    { "application", on_application },
  };
}

#hdr
#include <basil/fsm.h>
#include <string>
#include <vector>
#include <lua.hpp>
#end

#src
#include <basil/message.h>
#include <algorithm>
#include <map>
#include <stdexcept>

#define ARRAY_SIZE(X) (sizeof (X) / sizeof (X [0]))
#define ARRAY_END(X)  (X + ARRAY_SIZE(X))
#end
