// basilcc state table

namespace basilcc {

class BaseKernel;
class Compiler;
class FollowKernel;
class State;

typedef std::vector<State *> StateVector;

class StateTable {
  public:
    StateTable()
    {}

    ~StateTable ()
    {
        for (StateMap::value_type const &p: _states) {
            delete p.second;
        }
    }

    State const *get_state(Compiler &c, FollowKernel *follow_kernel)
    {
        BaseKernel const &base_kernel = follow_kernel->get_shift_kernel(c).get_base_kernel(c);
        std::pair<StateMap::iterator, StateMap::iterator> p = _states.equal_range(&base_kernel);
        for (StateMap::iterator i = p.first; i != p.second; ++i) {
            State const *state = i->second;
            if (state->get_follow_kernel() == follow_kernel || is_kernel_equiv(c, state->get_follow_kernel(), follow_kernel)) {
                return state;
            }
        }
        State const *state = _states.emplace_hint(p.second, &base_kernel, new State(_states.size(), follow_kernel))->second;
        _pending.push_back(const_cast<State *>(state));
        return state;
    }

    // get states in number order
    void get_states(StateVector &states) const
    {
        states.reserve(_states.size());
        for (StateMap::value_type const &p: _states) {
            states.push_back(p.second);
        }
        std::sort(states.begin(), states.end(), StateNumberLess());
    }

    // get all states
    int closure(Compiler &c, int &num_conflicts, int &num_lex_state_conflicts)
    {
        num_conflicts = 0;
        num_lex_state_conflicts = 0;
        create_start_states(c);
        while (!_pending.empty()) {
            State *state = _pending.front();
            _pending.pop_front();
            num_conflicts += state->closure(c);
            if (state->get_lex_state().is_conflict()) {
                ++num_lex_state_conflicts;
            }
        }
        return (int)_states.size();
    }

  private:
    // create all start states
    void create_start_states(Compiler &c)
    {
        RuleMapRange const &r = c.get_start_rules();
        for (RuleMap::const_iterator i = r.first; i != r.second; ++i) {
            Rule const *rule = i->second;
            BaseRule const *base_rule = c.get_base_rule(rule, 0);
            ShiftRule const *shift_rule = c.get_shift_rule(base_rule, Priority());
            FollowRuleVector follow_rules(1, c.get_follow_rule(shift_rule, get_start_follow(c, rule)));
            FollowKernel *follow_kernel = c.get_follow_kernel(follow_rules);
            get_state(c, follow_kernel);
        }
    }

  private:
    typedef std::multimap<BaseKernel const *, State *> StateMap;
    StateMap _states;
    std::deque<State *> _pending; // new states pending closure
};

namespace {

// true if kernels equivalent, produces the same moves
bool is_kernel_equiv(Compiler &c, FollowKernel *a_kernel, FollowKernel *b_kernel)
{
    // to avoid infinite loop
    std::set<BaseKernel const *> history;
    // initialize pending
    typedef std::pair<FollowKernel *, FollowKernel *> FollowKernelPair;
    std::deque<FollowKernelPair> pending;
    pending.push_back(FollowKernelPair(a_kernel, b_kernel));
    while (!pending.empty()) {
        FollowKernelPair const &p = pending.front();
        FollowBase const &a_follow_base = p.first->get_follow_base(c);
        FollowBase const &b_follow_base = p.second->get_follow_base(c);
        pending.pop_front();
        if (a_follow_base.get_lazy_follow_move() != b_follow_base.get_lazy_follow_move() ||
                a_follow_base.get_lex_state() != b_follow_base.get_lex_state()) {
            return false;
        }
        if (history.insert(&a_follow_base.get_shift_base().get_base_kernel()).second) {
            FollowShiftMap const &a_shifts = a_follow_base.get_follow_shifts();
            FollowShiftMap const &b_shifts = b_follow_base.get_follow_shifts();
            for (FollowShiftMap::const_iterator i = a_shifts.begin(), endi = a_shifts.end(), j = b_shifts.begin(); i != endi; ++i, ++j) {
                if (i->second != j->second) {
                    pending.push_back(FollowKernelPair(i->second, j->second));
                }
            }
        }
    }
    return true;
}

// return follow for start rule
Follow get_start_follow(Compiler &c, Rule const *rule)
{
    Follow follow;
    bool sticky = true, accept = true;
    Symbol *shortcut = c.get_start_symbol();
    bool null = true;
    RuleSymbolVector const &explicit_follow = rule->get_explicit_follow();
    if (!explicit_follow.empty ()) {
        null = false;
        for (RuleSymbol const &rule_symbol: explicit_follow) {
            Symbol *symbol = rule_symbol.get_symbol();
            First const &first = symbol->get_first();
            follow.add_first(first, rule_symbol.get_lex_state(), shortcut, rule_symbol.get_first_priority(), sticky, accept);
            if (first.has_null()) {
                null = true;
            }
        }
    }
    if (null) {
        First const& first = c.get_eot_symbol()->get_first();
        follow.add_first(first, LexState(), shortcut, Priority(), sticky, accept);
    }
    return follow;
}

} // unamed
} // basilcc

#hdr
#include <map>
#include <vector>
#include <deque>
#end

#src
#include <basilcc_compiler.h>
#include <basilcc_follow.h>
#include <basilcc_follow_base.h>
#include <basilcc_follow_kernel.h>
#include <basilcc_rule.h>
#include <basilcc_shift_base.h>
#include <basilcc_shift_kernel.h>
#include <basilcc_state.h>
#include <basilcc_symbol.h>
#include <basilcc_util.h>
#include <deque>
#include <set>

// DEBUG
#include <basilcc_base_kernel.h>
#include <basilcc_base_rule.h>
#include <iostream>
// DEBUG
#end
