namespace basilcx {

class Action;
class ActionSeq;
class Move;

class Workspace {
  public:
    Workspace()
        : rules(*this)
    {
        start_symbol = symbols.get_symbol(intern("start"));
        eot_symbol = symbols.get_symbol(intern("EOT"));
    }

    ~Workspace()
    {}

    // tables
    SymbolTable symbols;
    NodeTable nodes;
    RuleTable rules;
    BaseRuleTable base_rules;
    ShiftRuleTable shift_rules;
    FollowRuleTable follow_rules;
    BaseKernelTable base_kernels;
    ShiftKernelTable shift_kernels;
    FollowKernelTable follow_kernels;
    ActionTable actions;
    ActionSeqTable action_seqs;
    MoveTable moves;
    MoveSelTable move_sels;
    LazyActionTable lazy_actions;
    LazyActionSeqTable lazy_action_seqs;
    LazyMoveTable lazy_moves;
    LazyMoveSelTable lazy_move_sels;
    LazyFollowMoveTable lazy_follow_moves;
    ShiftSelTable shift_sels;
    StateMoveTable state_moves;
    StateTable states;
    ShiftStateSelTable shift_state_sels;
    // special symbols
    Symbol *start_symbol;
    Symbol *eot_symbol;

    // intern string, return shared char const *
    inline char const *intern(std::string const &str)
    {
      return strings.insert(str).first->c_str ();
    }

    // type of user object
    std::string usertype;
    std::string fsm_namespace;

    /*
    // generated parser namespace 
    std::string parser_namespace;
    std::string userdata_class;
    */

    // rules
    inline Rule *add_rule(
        Node *node,
        RuleSymbol const &left_rule_symbol,
        RuleSymbolVector const &right_rule_symbols,
        RuleSymbolVector const &explicit_follow,
        bool no_bypass
    )
    {
        return rules.add_rule(
            node,
            left_rule_symbol,
            right_rule_symbols,
            explicit_follow,
            no_bypass);
    }

    inline bool is_start_symbol(Symbol *symbol) const
    {
        return symbol == start_symbol;
    }

    // get all start rules
    inline RuleMapRange get_start_rules() const
    {
        return rules.get_rules(start_symbol);
    }

    // get state from follow kernel
    inline State *get_state(FollowKernel *follow_kernel)
    {
        return states.get_state(*this, follow_kernel);
    }

    // create all states, return true if no conflicts, otherwise set number of conflicts and return false
    inline bool create_states(int &num_conflicts, int &num_lex_state_conflicts)
    {
        return states.create_states(*this, num_conflicts, num_lex_state_conflicts);
    }

  private:
    std::set<std::string> strings;
};

} // basilcx

#hdr
#include <basilcx_action_seq_table.h>
#include <basilcx_action_table.h>
#include <basilcx_base_kernel_table.h>
#include <basilcx_base_rule_table.h>
#include <basilcx_follow_kernel_table.h>
#include <basilcx_follow_rule_table.h>
#include <basilcx_lazy_action_seq_table.h>
#include <basilcx_lazy_action_table.h>
#include <basilcx_lazy_follow_move_table.h>
#include <basilcx_lazy_move_sel_table.h>
#include <basilcx_lazy_move_table.h>
#include <basilcx_move_sel_table.h>
#include <basilcx_move_table.h>
#include <basilcx_node_table.h>
#include <basilcx_rule_table.h>
#include <basilcx_shift_kernel_table.h>
#include <basilcx_shift_rule_table.h>
#include <basilcx_shift_sel_table.h>
#include <basilcx_state_move_table.h>
#include <basilcx_state_table.h>
#include <basilcx_symbol_table.h>
#end
