// basilcc_follow_rule
//
// shift rule with follow set
//

namespace basilcc {

class Compiler;
class Follow;
class ShiftRule;

typedef std::unique_ptr<Follow> FollowPtr;

class FollowRule {
  public:
    FollowRule(ShiftRule const *shift_rule)
      : _shift_rule(shift_rule)
    {}

    FollowRule(ShiftRule const *shift_rule, Follow const &follow)
      : _shift_rule(shift_rule), _follow(follow)
    {}

    ~FollowRule()
    {}

    // get shift rule
    inline ShiftRule const *get_shift_rule() const
    {
        return _shift_rule;
    }

    // get follow set
    inline Follow const &get_follow() const
    {
        return _follow;
    }

    // update follow, return true if rule changed
    bool update(Follow const &follow)
    {
        return _follow.update(follow);
    }

    // get next follow
    void get_next_follow(Follow &follow) const
    {
        BaseRule const *base_rule = _shift_rule->get_base_rule();
        Rule const *rule = base_rule->get_rule();
        RuleSymbol const &next_rule_symbol = base_rule->get_next_rule_symbol();
        RuleSymbol const &left_rule_symbol = base_rule->get_left_rule_symbol();
        Symbol *shortcut = next_rule_symbol.get_symbol();
        Priority rp = _shift_rule->get_shift_priority() + left_rule_symbol.get_shift_priority() + next_rule_symbol.get_reduce_priority();
        bool sticky = next_rule_symbol.has_sticky();
        bool accept = next_rule_symbol.has_accept();
        // add first of next symbols while null
        bool null = true;
        for (int i = base_rule->get_pos() + 1, endi = rule->get_size(); null && i != endi; ++i) {
            RuleSymbol const &rule_symbol = rule->get_right_rule_symbol(i);
            Symbol *symbol = rule_symbol.get_symbol();
            First const &first = symbol->get_first();
            Priority first_rp = rp + rule_symbol.get_first_priority(); 
            follow.add_first(first, rule_symbol.get_lex_state(), shortcut, first_rp, sticky, accept);
            null = first.has_null();
        }
        if (null) {
            rp = left_rule_symbol.get_reduce_priority() + next_rule_symbol.get_reduce_priority();
            if (rule->can_bypass()) {
                sticky = sticky || left_rule_symbol.has_sticky();
                accept = accept || left_rule_symbol.has_accept();
                follow.add_follow(_follow, rp, sticky, accept);
            }
            else {
                follow.add_follow(_follow, shortcut, rp, sticky, accept);
            }
        }
    }

    // get lex state
    LexState get_lex_state() const
    {
        LexState lex_state;
        BaseRule const *base_rule = _shift_rule->get_base_rule();
        Rule const *rule = base_rule->get_rule();
        RuleSymbolVector const &rule_symbols = rule->get_right_rule_symbols();
        int pos = base_rule->get_pos();
        bool null = true;
        for (RuleSymbolVector::const_iterator i = rule_symbols.begin() + pos; null && i != rule_symbols.end(); ++i) {
            RuleSymbol const &rule_symbol = *i;
            lex_state.update(rule_symbol.get_lex_state());
            First const &first = rule_symbol.get_symbol()->get_first();
            lex_state.update(first.get_lex_state());
            null = first.has_null();
        }
        if (null) {
            lex_state.update(_follow.get_lex_state());
        }
        return lex_state;
    }

    // get follow rule at next pos
    FollowRule const *get_next_follow_rule(Compiler &c) const
    {
        return c.get_follow_rule(_shift_rule->get_next_shift_rule(c), _follow);
    }

  private:
    ShiftRule const *_shift_rule;
    Follow _follow;
};

// true if a < b
bool operator <(FollowRule const &a, FollowRule const &b)
{
    if (a.get_shift_rule() != b.get_shift_rule()) {
        return *a.get_shift_rule() < *b.get_shift_rule();
    }
    return a.get_follow() < b.get_follow();
}
inline bool FollowRuleLess(; FollowRule const *a, FollowRule const *b) const
{
    return *a < *b;
}

} // basilcc

#hdr
#include <basilcc_follow.h>
#include <memory>
#end

#src
#include <basilcc_base_rule.h>
#include <basilcc_compiler.h>
#include <basilcc_rule.h>
#include <basilcc_shift_rule.h>
#include <basilcc_symbol.h>
#end
