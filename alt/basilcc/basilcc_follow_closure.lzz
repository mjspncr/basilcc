// basilcc follow closure

namespace basilcc {

class Compiler;
typedef std::map<Symbol const *, FollowKernel const *> FollowShiftMap;

// follow closure
void follow_closure(
    Compiler &c,
    ShiftBase const *shift_base,
    FollowRuleVector &follow_rules,
    FollowShiftMap &follow_shifts,
    LazyFollowMove const *&lazy_follow_move,
    LexState &lex_state,
    ConflictVector &conflicts)
{
    get_non_kernel_follow_rules(c, shift_base, follow_rules);
    get_follow_shifts(c, follow_rules, follow_shifts);
    lazy_follow_move = get_lazy_follow_move(c, follow_rules, conflicts);
    lex_state = get_lex_state(follow_rules, shift_base->get_base_kernel()->get_kernel_size());
}

namespace {

// append non kernel follow rules
void get_non_kernel_follow_rules(Compiler &c, ShiftBase const *shift_base, FollowRuleVector &follow_rules)
{
    int kernel_size = follow_rules.size();
    ShiftRuleVector const &shift_rules = shift_base->get_shift_rules();
    FollowRuleMap non_kernel_follow_rules;
    for (ShiftRuleVectorConstIter i = shift_rules.begin() + kernel_size, endi = shift_rules.end(); i != endi; ++i) {
        ShiftRule const *shift_rule = *i;
        non_kernel_follow_rules.emplace(shift_rule->get_left_symbol(), FollowRulePtr(new FollowRule(shift_rule)));
    }
    FollowBaseClosure(follow_rules, non_kernel_follow_rules).submit ();
    for (FollowRuleMap::value_type const &p: non_kernel_follow_rules) {
        follow_rules.push_back(c.freeze_follow_rule(p.second));
    }
}

// follow base closure
typedef std::unique_ptr<FollowRule> FollowRulePtr;
typedef std::multimap<Symbol const *, FollowRulePtr> FollowRuleMap;
class FollowBaseClosure(FollowRuleVector const &kernel_rules, FollowRuleMap &non_kernel_rules)
{
  public:
    // start closure
    void start()
    {
        for (FollowRule const *follow_rule: kernel_rules) {
            BaseRule const *base_rule = follow_rule->get_shift_rule()->get_base_rule();
            if (!base_rule->is_reduction()) {
                Symbol const *symbol = base_rule->get_next_symbol();
                if (!symbol->is_token()) {
                    Follow follow;
                    follow_rule->get_next_follow(follow);
                    update(symbol, follow);
                }
            }
        }
    }

  private:
    // update follow rules with left hand symbol 
    void update(Symbol const *symbol, Follow const &follow)
    {
        typedef FollowRuleMap::const_iterator FollowRuleMapConstIter;
        std::pair<FollowRuleMapConstIter, FollowRuleMapConstIter> r = non_kernel_rules.find(symbol);
        for (FollowRuleMapConstIter i = r.first, endi = r.second; i != endi; ++i) {
            FollowRule *follow_rule = (*i).get();
            BaseRule const *base_rule = follow_rule->get_shift_rule()->get_base_rule();
            if (follow_rule->update(follow) && !base_rule->is_reduction()) {
                Symbol const *symbol = base_rule->get_next_symbol();
                if (!symbol->is_token()) {
                    Follow follow;
                    follow_rule->get_next_follow(follow);
                    update(symbol, follow); // can sure this will not recurse endlessly?
                }
            }
        }
    }
};

// get follow shifts
void get_follow_shifts(Compiler &c, FollowRuleVector const &follow_rules, FollowShiftMap &follow_shifts)
{
    for (FollowRuleVector::const_iterator i = follow_rules.begin(), endi = follow_rules.end(); i != endi; ++i) {
        FollowRule const *follow_rule = *i; 
        BaseRule const *base_rule = follow_rule->get_shift_rule()->get_base_rule();
        if (!(base_rule->is_reduction() || base_rule->get_rule()->can_bypass())) {
            Symbol const *symbol = base_rule->get_next_symbol();
            std::pair<FollowShiftMap::iterator, bool> r = follow_shifts.emplace(symbol, NULL);
            if (r.second) {
                FollowRuleVector kernel_rules;
                // only need to search for kernel rules from i 
                std::for_each(i, endi, GetFollowKernelRules(c, symbol, kernel_rules));
                std::sort(kernel_rules.begin(), kernel_rules.end(), FollowRuleLess());
                r.first->second = c.get_follow_kernel(kernel_rules);
            }
        }
    }
}

// add follow rule to kernel rules if symbol is next symbol
void GetFollowKernelRules(Compiler &c, Symbol const *symbol, FollowRuleVector &kernel_rules; FollowRule const *follow_rule) const
{
    BaseRule const *base_rule = follow_rule->get_shift_rule()->get_base_rule();
    if (!(base_rule->is_reduction() || base_rule->get_rule()->can_bypass()) && base_rule->get_next_symbol() == symbol) {
        kernel_rules.push_back(c.get_next_follow_rule(follow_rule));
    }
}

// get lazy follow move
LazyFollowMove const *get_lazy_follow_move(Compiler &c, FollowRuleVector const &follow_rules, ConflictVector &conflicts)
{
    TempFollowMove temp_follow_move;
    for (FollowRule const *follow_rule: follow_rules) {
      ShiftRule const *shift_rule = follow_rule->get_shift_rule();
      BaseRule const *base_rule = shift_rule->get_base_rule();
      if (base_rule->is_reduction()) {
          // add reduction (except if rule is bypassed)
          Rule const *rule = base_rule->get_rule();
          if (!rule->can_bypass()) {
              RuleSymbol const &left_rule_symbol = rule->get_left_rule_symbol();
              Priority priority = left_rule_symbol.get_reduce_priority();
              bool sticky = left_rule_symbol.has_sticky();
              bool accept = left_rule_symbol.has_accept();
              FollowPtr follow = follow_rule->getFollow ();
          temp_follow_move.addReduction (rule, follow, priority, sticky, accept);
        }
      }
      else
      {
        // add shift if next symbol is a token
        SymbolPtr symbol = base_rule->getNextSymbol ();
        if (symbol->isToken ())
        {
          Priority priority = base_rule->getShiftPriority () + shift_rule->getShiftPriority ();
          temp_follow_move.addShift (symbol, priority);
        }
      }
    }
    temp_follow_move.freeze ();
    LazyFollowMovePtr lazy_follow_move = temp_follow_move.getLazyFollowMove (cc);
    // getConflicts may take actions so call after getLazyFollowMove
    temp_follow_move.getConflicts (conflicts);
    return lazy_follow_move;
  }

  // update follow lex state
  void UpdateLexState (LexState & lex_state; FollowRulePtr follow_rule) const
  {
    lex_state.update (follow_rule->getLexState ());
  }

  // get follow lex state
  LexState getLexState (FollowRulePtrVector const & follow_rules, int kernel_size)
  {
    // only need to pull lex state from kernel rules
    LexState lex_state;
    for_each (follow_rules.begin (), follow_rules.begin () + kernel_size, UpdateLexState (lex_state));
    return lex_state;
  }
}

#hdr
#include <basilcc/conflict_ptr_vector.h>
#include <basilcc/follow_rule_ptr_vector.h>
#include <basilcc/follow_shift_list.h>
#include <basilcc/lazy_follow_move_ptr.h>
#include <basilcc/lex_state.h>
#include <basilcc/shift_base_ptr.h>
#end

#src
#include <basilcc/base_kernel.h>
#include <basilcc/base_rule.h>
#include <basilcc/follow.h>
#include <basilcc/follow_kernel_api.h>
#include <basilcc/follow_rule.h>
#include <basilcc/follow_rule_api.h>
#include <basilcc/rule.h>
#include <basilcc/rule_symbol.h>
#include <basilcc/shift_base.h>
#include <basilcc/shift_rule.h>
#include <basilcc/symbol.h>
#include <basilcc/temp_action.h>
#include <basilcc/temp_follow_move.h>
#include <basilcc/temp_follow_move_ptr.h>
#include <basilcc/temp_move.h>
#include <algorithm>
#include <memory>
#end
