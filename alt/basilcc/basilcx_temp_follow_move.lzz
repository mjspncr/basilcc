namespace basilcx {

class Conflict;
class Follow;
class LazyFollowMove;
class Rule;
class Symbol;
class TempMove;
class Workspace;
typedef std::vector<Conflict *> ConflictVector;

class TempFollowMove {
  public:
    TempFollowMove()
    {}

    ~TempFollowMove()
    {
        delete_values(_temp_moves);
    }

    // add reduction to move
    void add_reduction(Rule const *rule, Follow const &follow, Priority const &priority, bool accept, bool sticky)
    {
        for (FollowItem const &follow_item: follow.get_follow_items()) {
            TempMove *temp_move = get_temp_move(follow_item.get_token());
            temp_move->add_reduction(
                rule,
                follow_item.get_shortcut(),
                follow_item.get_reduce_priority() + priority,
                follow_item.has_accept() || accept,
                follow_item.has_sticky() || sticky);
        }
    }

    // add shift to move
    void add_shift(Symbol *term, Priority const &priority)
    {
        // add shift to priority action
        TempMove *temp_move = get_temp_move(term);
        temp_move->add_shift(priority);
    }

    // return lazy follow move and set conflicts
    LazyFollowMove const *get_lazy_follow_move(Workspace &w, ConflictVector &conflicts) const
    {
        if (!_temp_moves.empty() && _temp_moves.begin()->second->debug()) {
            _temp_moves.begin()->second->debug();
        }

        // get lazy moves and conflicts, put moves that can be replaced with a default action seq reduce_moves
        typedef std::vector<LazyMove const *> LazyMoveVector;
        LazyMoveVector moves, reduce_moves;
        {
            LazyReduceSet sticky_reductions;
            for (TempMoveMap::value_type const &p: _temp_moves) {
                TempMove *temp_move = p.second;
                LazyMove *lazy_move = temp_move->get_lazy_move(w, conflicts);
                bool sticky = temp_move->is_sticky();
                if (!sticky && lazy_move->get_lazy_action_seq()->is_reduction()) {
                    reduce_moves.push_back(lazy_move);
                }
                else {
                    // if sticky note all reductions
                    if (sticky) {
                        for (LazyAction const *action: lazy_move->get_lazy_action_seq()->get_lazy_actions()) {
                            if (action->is_reduction()) {
                                sticky_reductions.insert(action);
                            }
                        }
                    }
                    moves.push_back(lazy_move);
                }
            }
            ContainsLazyAction contains(sticky_reductions);
            LazyMoveVector::iterator p = std::partition(reduce_moves.begin(), reduce_moves.end(), contains);
            moves.insert(moves.end(), reduce_moves.begin(), p);
            reduce_moves.erase(reduce_moves.begin(), p);
        }

        // get the default move
        LazyActionSeq const *def_lazy_action_seq = NULL;
        if (!reduce_moves.empty()) {
            std::sort(reduce_moves.begin(), reduce_moves.end(), LazyMoveReduceSeqLess());
            std::pair<LazyMoveVector::iterator, LazyMoveVector::iterator> r = most(reduce_moves.begin(), reduce_moves.end(), LazyMoveReduceSeqSame());
            // grab default seq and add rest to moves  
            def_lazy_action_seq = (*r.first)->get_lazy_action_seq();
            moves.insert(moves.end(), reduce_moves.begin(), r.first);
            moves.insert(moves.end(), r.second, reduce_moves.end());
        }
        else {
            LazyActionVector lazy_actions;
            def_lazy_action_seq = w.lazy_action_seqs.get_lazy_action_seq(lazy_actions);
        }

        // sort lazy moves by token then get lazy move sel
        std::sort(moves.begin(), moves.end(), LazyMoveTokenLess());
        LazyMoveSel const *lazy_move_sel = w.lazy_move_sels.get_lazy_move_sel(moves);
        return w.lazy_follow_moves.get_lazy_follow_move(lazy_move_sel, def_lazy_action_seq);
    }

  private:
    // get temp_move for token, create if doesn't exist
    TempMove *get_temp_move(Symbol *token)
    {
        std::pair<TempMoveMap::iterator, bool> r = _temp_moves.emplace(token, (TempMove *)NULL);
        if (r.second) {
            r.first->second = new TempMove(token);
        }
        return r.first->second;
    }

  private:
    typedef std::map<Symbol *, TempMove *> TempMoveMap;
    TempMoveMap _temp_moves;
};

namespace {

// true if token less in lazy move, used to sort lazy moves, does NOT compare pointers
bool LazyMoveTokenLess(; LazyMove const *a, LazyMove const *b) const
{
    return *a->get_token() < *b->get_token();
}

bool LazyReduceLess(; LazyAction const *a, LazyAction const *b) const
{
    if (a != b) {
        ReduceLazyAction const &a_reduce = static_cast<ReduceLazyAction const &>(*a);
        ReduceLazyAction const &b_reduce = static_cast<ReduceLazyAction const &>(*b);
        if (a_reduce.get_rule() != b_reduce.get_rule()) {
            return a_reduce.get_rule() < b_reduce.get_rule();
        }
        if (a_reduce.get_shortcut() != b_reduce.get_shortcut()) {
            return a_reduce.get_shortcut() < b_reduce.get_shortcut();
        }
    }
    return false;
}
typedef std::set<LazyAction const *, LazyReduceLess> LazyReduceSet;

// true if actions contains any action in lazy move
bool ContainsLazyAction(LazyReduceSet const &actions; LazyMove const *a) const
{
    for (LazyAction const *reduce_action: a->get_lazy_action_seq()->get_lazy_actions()) {
        if (actions.find(reduce_action) != actions.end()) {
            return true;
        }
    }
    return false;
}

// true if reduce action seq in moves the same
bool LazyMoveReduceSeqLess(; LazyMove const *a, LazyMove const *b) const
{
    LazyActionVector const &a_actions = a->get_lazy_action_seq()->get_lazy_actions();
    LazyActionVector const &b_actions = b->get_lazy_action_seq()->get_lazy_actions();
    if (a_actions.size() != b_actions.size()) {
        return a_actions.size() < b_actions.size();
    }
    LazyActionVector::const_iterator j = b_actions.begin();
    for (LazyActionVector::const_iterator i = a_actions.begin(), endi = a_actions.end(); i != endi; ++i, ++j) {
        LazyAction const *a_action = *i;
        LazyAction const *b_action = *j;
        if (i == j) {
            continue;
        }
        ReduceLazyAction const &a_reduce = static_cast<ReduceLazyAction const &>(*a_action);
        ReduceLazyAction const &b_reduce = static_cast<ReduceLazyAction const &>(*b_action);
        if (a_reduce.get_rule() != b_reduce.get_rule()) {
            return a_reduce.get_rule() < b_reduce.get_rule();
        }
        if (a_reduce.get_shortcut() != b_reduce.get_shortcut()) {
            return a_reduce.get_shortcut() < b_reduce.get_shortcut();
        }
        // order accept first just so that it'll be first if most same
        if (a_reduce.has_accept() != b_reduce.has_accept()) {
            return a_reduce.has_accept();
        }
    }
    return false;
}

bool LazyMoveReduceSeqSame(; LazyMove const *a, LazyMove const *b) const
{
    LazyActionVector const &a_actions = a->get_lazy_action_seq()->get_lazy_actions();
    LazyActionVector const &b_actions = b->get_lazy_action_seq()->get_lazy_actions();
    if (a_actions.size() != b_actions.size()) {
        return false;
    }
    LazyActionVector::const_iterator j = b_actions.begin();
    for (LazyActionVector::const_iterator i = a_actions.begin(), endi = a_actions.end(); i != endi; ++i, ++j) {
        LazyAction const *a_action = *i;
        LazyAction const *b_action = *j;
        if (i == j) {
            continue;
        }
        // still might be same if ignore accept
        ReduceLazyAction const &a_reduce = static_cast<ReduceLazyAction const &>(*a_action);
        ReduceLazyAction const &b_reduce = static_cast<ReduceLazyAction const &>(*b_action);
        if (a_reduce.get_rule() != b_reduce.get_rule()) {
            return false;
        }
        if (a_reduce.get_shortcut() != b_reduce.get_shortcut()) {
            return false;
        }
    }
    return true;
}

} // unnamed
} // basilcc

#hdr
#include <basilcx_priority.h>

#include <map>
#include <vector>
#end

#src
#include <basilcx_first.h>
#include <basilcx_follow.h>
#include <basilcx_follow_item.h>
#include <basilcx_lazy_action.h>
#include <basilcx_lazy_action_seq.h>
#include <basilcx_lazy_move.h>
#include <basilcx_symbol.h>
#include <basilcx_temp_move.h>
#include <basilcx_util.h>
#include <basilcx_workspace.h>

#include <algorithm>
#end
