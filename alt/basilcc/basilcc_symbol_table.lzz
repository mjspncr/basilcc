// basilcc_symbol_table
//
// maintains all symbols
//

namespace basilcc {

class Symbol;
class Compiler;

class SymbolTable
{
  public:
    SymbolTable(Compiler &c)
    {
        _eot = get_symbol(c.intern("EOT"));
        _start = get_symbol(c.intern("start"));
    }

    ~SymbolTable()
    {
        delete_objects(_tokens.begin(), _tokens.end());
        delete_objects(_nonterminals.begin(), _nonterminals.end());
    }

    // get EOT symbol
    Symbol *get_eot_symbol() const
    {
        return _eot;
    }

    // get start symbol
    Symbol *get_start_symbol() const
    {
        return _start;
    }

    // get symbol from name, new symbol if doesn't exist
    Symbol *get_symbol(char const *name)
    {
        Symbol *&symbol = _symbols[name];
        if (!symbol) {
            if (is_token(name)) {
                symbol = *_tokens.insert(_tokens.end(), new Token(name));
            }
            else {
                symbol = *_nonterminals.insert(_tokens.end(), new Nonterminal(name));
            }
        }
        return symbol;
    }

  private:
    // tokens and nonterminals, owns the symbols
    std::vector<Symbol *> _tokens;
    std::vector<Symbol *> _nonterminals;
    // index of symbols by name
    typedef std::map<char const *, Symbol *> SymbolMap;
    SymbolMap _symbols;
    // special symbols EOT and start
    Symbol *_eot;
    Symbol *_start;
};

namespace {
// true if name is a token, if no lower case characters
bool is_token(char const *name)
{
    for (char const *p = name; *p != '\0'; ++p)
    {
        if (islower(*p))
        {
            return false;
        }
    }
    return true;
}
} // unnamed
} // basilcc

#hdr
#include <map>
#include <vector>
#end

#src
#include <basilcc_compiler.h>
#include <basilcc_symbol.h>
#include <basilcc_util.h>
#include <ctype.h>
#end
