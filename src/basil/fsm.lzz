namespace basil
{
  typedef std::vector <int> IntVector;
  typedef std::pair <std::string, int> StringIntPair;
  typedef std::vector <StringIntPair> StringIntVector;
  typedef std::map <std::string, int> StringIntMap;

  // finite state machine
  class FSM
  {
  public:
    // token_numbers_beg and token_numbers_beg iterators to real token name, number pairs
    FSM (std::string const & fsm_filename, TokenNumberPtr token_numbers_beg, TokenNumberPtr token_numbers_end)
    {
      ifstream is (fsm_filename.c_str (), ios_base::in | ios_base::binary);
      if (! is)
      {
        throw runtime_error (Message ("failed to open parser FSM: %") << fsm_filename);
      }
      BinaryReader r (is);
      readKeywords (r);
      readNodes (r);
      readRules (r);
      readActionSeqs (r);
      IntVector tokens;
      getTokens (r, token_numbers_beg, token_numbers_end, tokens);
      readMoveSels (r, tokens);
      readStates (r);
      readShiftStateSels (r);
      readGotos (r);
      readStrategies (r, tokens);
    }
    ~ FSM ()
    {}
    // types
    struct Rule (int size, int node) {}
    struct Move (int token, int action_seq) {}
    struct Action (int kind, int arg1, int arg2) {}
    struct State (int move_sel, int def_action_seq, int lex_state, int num) {}
    struct ShiftState (int num, int state) {}
    struct Goto (int shift_state_sel, int def_state) {}

    typedef std::vector <Rule> RuleVector;
    typedef Move const * MovePtr;
    typedef std::vector <Move> MoveVector;
    typedef std::vector <MovePtr> MovePtrVector;
    typedef Action const * ActionPtr;
    typedef std::vector <Action> ActionVector;
    typedef std::vector <ActionPtr> ActionPtrVector;
    typedef std::vector <State> StateVector;
    typedef ShiftState const * ShiftStatePtr;
    typedef std::vector <ShiftState> ShiftStateVector;
    typedef std::vector <ShiftStatePtr> ShiftStatePtrVector;
    typedef std::vector <Goto> GotoVector;
    typedef std::pair <ActionPtr, ActionPtr> ActionPtrPair;

    // constants
    enum { REDUCE = 1, ACCEPT, SHIFT, DONE }
    enum { NOINDEX = -1 }

    // recover strategy
    enum StrategyType { STRATEGY_INSERT, STRATEGY_DELETE }
    struct Strategy
    {
      virtual ~ Strategy () {}
      virtual StrategyType getType () const = 0;
    };
    struct InsertStrategy : Strategy
    {
      InsertStrategy (int token, std::string const & lexeme) : token (token), lexeme (lexeme) {}
      ~ InsertStrategy () {}
      FSM::StrategyType getType () const { return STRATEGY_INSERT; }
      int token;
      std::string lexeme;
    }
    struct DeleteStrategy : Strategy
    {
      DeleteStrategy (int number) : number (number) {}
      ~ DeleteStrategy () {}
      FSM::StrategyType getType () const { return STRATEGY_DELETE; }
      int number;
    }
    typedef Strategy const * StrategyPtr;
    typedef std::vector <StrategyPtr> StrategyPtrVector;

  protected:
    int m_num_start_rules;
    StringIntVector m_keywords;
    StringVector m_nodes;
    RuleVector m_rules;
    ActionVector m_action_seqs;
    ActionPtrVector m_action_seqs_beg;
    MoveVector m_move_sels;
    MovePtrVector m_move_sels_beg;
    StateVector m_states;
    ShiftStateVector m_shift_state_sels;
    ShiftStatePtrVector m_shift_state_sels_beg;
    GotoVector m_gotos;
    StrategyPtrVector m_strategies;

  private:
    // keywords
    void readKeywords (BinaryReader & r)
    {
      StringVector lexemes;
      readStringVector (r, lexemes);
      if (! lexemes.empty ())
      {
        int start_number = r.readInt ();
        transform (lexemes.begin (), lexemes.end (), back_inserter (m_keywords), SetNumber (start_number));
      }
    }
    inline StringIntPair SetNumber (int number = 0; std::string & str)
    {
      return StringIntPair (str, number ++);
    }

    // nodes
    void readNodes (BinaryReader & r)
    {
      readStringVector (r, m_nodes);
    }

    // rules
    void readRules (BinaryReader & r)
    {
      int size = r.readInt ();
      m_num_start_rules = r.readInt ();
      m_rules.reserve (size);
      generate_n (back_inserter (m_rules), size, ReadRule (r));
    }
    inline FSM::Rule ReadRule (BinaryReader & r;) const
    {
      int size = r.readInt ();
      int node = r.readInt ();
      return Rule (size, node);
    }

    // actions
    void readActionSeqs (BinaryReader & r)
    {
      int size = r.readInt ();
      m_action_seqs.reserve (size);
      generate_n (back_inserter (m_action_seqs), size, ReadAction (r));
      IntVector nums;
      readVector (r, nums);
      m_action_seqs_beg.reserve (nums.size () + 1);
      m_action_seqs_beg.push_back (& m_action_seqs [0]);
      transform (nums.begin (), nums.end (), back_inserter (m_action_seqs_beg), GetActionPtr (m_action_seqs));
    }
    inline FSM::Action ReadAction (BinaryReader & r;) const
    {
      int kind = r.readInt ();
      int arg1 = r.readInt ();
      int arg2 = kind == SHIFT ? NOINDEX : r.readInt ();
      return Action (kind, arg1, arg2);
    }
    inline FSM::ActionPtr GetActionPtr (ActionVector const & actions; int num) const
    {
      return & actions [num];
    }

    // read token names and set real token numbers
    void getTokens (BinaryReader & r, TokenNumberPtr token_numbers_beg, TokenNumberPtr token_numbers_end, IntVector & tokens)
    {
      StringVector names;
      readStringVector (r, names);
      typedef vector <TokenNumber> TokenNumberVector;
      TokenNumberVector token_numbers_sorted (token_numbers_beg, token_numbers_end);
      sort (token_numbers_sorted.begin (), token_numbers_sorted.end (), tokenNumberNameLess1);
      tokens.reserve (names.size ());
      for (StringVector::const_iterator i = names.begin (), endi = names.end (); i != endi; ++ i)
      {
        string const & name = * i;
        TokenNumberVector::iterator t = lower_bound (token_numbers_sorted.begin (), token_numbers_sorted.end (), name, tokenNumberNameLess2);
        if (t == token_numbers_sorted.end () || t->name != name)
        {
          throw runtime_error (Message ("Missing token number for %") << name);
        }
        tokens.push_back (t->num);
      }
    }

    // moves, tokens is real token numbers
    void readMoveSels (BinaryReader & r, IntVector const & tokens)
    {
      // read all moves, filling in with real operator numbers
      int size = r.readInt ();
      m_move_sels.reserve (size);
      generate_n (back_inserter (m_move_sels), size, ReadMove (r, tokens));
      // now move selections, just ptrs into moves
      IntVector nums;
      readVector (r, nums);
      m_move_sels_beg.reserve (nums.size () + 1);
      m_move_sels_beg.push_back (& m_move_sels [0]);
      transform (nums.begin (), nums.end (), back_inserter (m_move_sels_beg), GetMovePtr (m_move_sels));
      // finally have to resort moves in selection by token number since swapped operator numbers, can't assume still in order
      for (MovePtrVector::iterator i = m_move_sels_beg.begin (), j = i + 1, endj = m_move_sels_beg.end (); j != endj; i = j, ++ j)
      {
        Move * p = const_cast <Move *> (* i);
        Move * q = const_cast <Move *> (* j);
        sort (p, q, MoveTokenLess ());
        i = j;
      }
    }
    // read move
    inline FSM::Move ReadMove (BinaryReader & r, IntVector const & tokens;) const
    {
      int token = r.readInt ();
      // keyword if token >= size, don't need to translate
      if (size_t (token) < tokens.size ())
      {
        token = tokens [token];
      }
      int action_seq_num = r.readInt ();
      return Move (token, action_seq_num);
    }
    inline FSM::MovePtr GetMovePtr (MoveVector const & moves; int num) const
    {
      return & moves [num];
    }

    // states
    void readStates (BinaryReader & r)
    {
      int size = r.readInt ();
      m_states.reserve (size);
      generate_n (back_inserter (m_states), size, ReadState (r));
    }
    inline FSM::State ReadState (BinaryReader & r;) const
    {
      int move_sel = r.readInt ();
      int def_action_seq = r.readInt ();
      int lex_state = r.readInt ();
      int num = r.readInt ();
      return State (move_sel, def_action_seq, lex_state, num);
    }

    // shift states
    void readShiftStateSels (BinaryReader & r)
    {
      int size = r.readInt ();
      m_shift_state_sels.reserve (size);
      generate_n (back_inserter (m_shift_state_sels), size, ReadShiftState (r));
      IntVector nums;
      readVector (r, nums);
      m_shift_state_sels_beg.reserve (nums.size () + 1);
      m_shift_state_sels_beg.push_back (& m_shift_state_sels [0]);
      transform (nums.begin (), nums.end (), back_inserter (m_shift_state_sels_beg), GetShiftStatePtr (m_shift_state_sels));
    }
    inline FSM::ShiftState ReadShiftState (BinaryReader & r;) const
    {
      int num = r.readInt ();
      int state = r.readInt ();
      return ShiftState (num, state);
    }
    inline FSM::ShiftStatePtr GetShiftStatePtr (ShiftStateVector const & shift_states; int num) const
    {
      return & shift_states [num];
    }

    // and gotos
    void readGotos (BinaryReader & r)
    {
      int size = r.readInt ();
      m_gotos.reserve (size);
      generate_n (back_inserter (m_gotos), size, ReadGoto (r));
    }
    inline FSM::Goto ReadGoto (BinaryReader & r;) const
    {
      int shift_state_sel = r.readInt ();
      int def_state = r.readInt ();
      return Goto (shift_state_sel, def_state);
    }

    // read recover strategies, tokens is real token numbers
    void readStrategies (BinaryReader & r, IntVector const & tokens)
    {
      int size = r.readInt ();
      generate_n (back_inserter (m_strategies), size, ReadStrategy (r, tokens));
    }
    FSM::StrategyPtr ReadStrategy (BinaryReader & r, IntVector const & tokens;) const
    {
      int type = r.readInt ();
      StrategyPtr strategy = 0;
      switch (type)
      {
        case STRATEGY_INSERT:
        {
          strategy = readInsertStrategy (r, tokens);
          break;
        }
        case STRATEGY_DELETE:
        {
          strategy = readDeleteStrategy (r);
          break;
        }
      }
      return strategy;
    }
    static FSM::StrategyPtr readInsertStrategy (BinaryReader & r, IntVector const & tokens)
    {
      int token = r.readInt ();
      // keyword if token >= size, don't need to translate
      if (size_t (token) < tokens.size ())
      {
        token = tokens [token];
      }
      string lexeme = r.readString ();
      // todo: translate token number (if not keyword)
      return new InsertStrategy (token, lexeme);
    }
    static FSM::StrategyPtr readDeleteStrategy (BinaryReader & r)
    {
      int number = r.readInt ();
      return new DeleteStrategy (number);
    }
  }
}

using namespace std;
using namespace basil;

namespace
{
  // true if token number name less
  bool tokenNumberNameLess1 (TokenNumber const & a, TokenNumber const & b)
  {
    return strcmp (a.name, b.name) < 0;
  }
  bool tokenNumberNameLess2 (TokenNumber const & a, string const & name)
  {
    return a.name < name;
  }

  // true if move token less
  inline bool MoveTokenLess (; FSM::Move const & a, FSM::Move const & b) const
  {
    return a.token < b.token;
  }
}

#hdr
#include <basil/bstream.h>
#include <basil/token_number.h>
#include <vector>
#include <map>
#end

#src
#include <basil/message.h>
#include <algorithm>
#include <cstring>
#include <fstream>
#include <limits>
#include <stdexcept>
#include <utility>
#end
