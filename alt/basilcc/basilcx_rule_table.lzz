namespace basilcx {

class Node;
class Rule;
class Symbol;
class RuleSymbol;
class Workspace;
typedef std::vector<RuleSymbol> RuleSymbolVector;
typedef std::vector<Rule *> RuleVector;
typedef std::multimap<Symbol *, Rule *> RuleMap;
typedef std::pair<RuleMap::const_iterator, RuleMap::const_iterator> RuleMapRange;

class RuleTable
{
  public:
    RuleTable(Workspace &w)
        : _w(w)
    {
        _enable_bypass = false; // TODO: read from config
    }

    ~RuleTable()
    {
        delete_values(_rules);
    }

    // add new rule
    Rule *add_rule(
        Node *node,
        RuleSymbol const &left_rule_symbol,
        RuleSymbolVector const &right_rule_symbols,
        RuleSymbolVector const &explicit_follow,
        bool no_bypass
    )
    {
        Symbol *left_symbol = left_rule_symbol.get_symbol();
        if (left_symbol->is_token()) {
            std::ostringstream ss;
            ss << "left hand symbol '" << left_symbol->get_name() << "' is a token";
            throw std::runtime_error(ss.str());
        }
        bool can_bypass = false;
        // can bypass rule on reduction if only one nonterminal on right hand side and no node
        if (_enable_bypass && !no_bypass && !node) {
            if (right_rule_symbols.size() == 1 && !right_rule_symbols.front().get_symbol()->is_token()) {
                can_bypass = true;
            }
        }
        return _rules.emplace_hint(_rules.end(), left_symbol,
                new Rule(
                    _rules.size(),
                    node,
                    left_rule_symbol,
                    right_rule_symbols,
                    explicit_follow,
                    _w.is_start_symbol(left_symbol),
                    can_bypass))->second;
    }

    // get vector of rules ordered by number
    void get_rules(RuleVector &rules) const
    {
        rules.reserve(_rules.size());
        for (RuleMap::value_type const &p: _rules) {
            rules.push_back(p.second);
        }
        std::sort(rules.begin(), rules.end(), RuleNumberLess());
    }

    // get rules with left hand symbol
    inline RuleMapRange get_rules(Symbol *left_symbol) const
    {
        return _rules.equal_range(left_symbol);
    }

    // true if left symbol
    inline bool is_left_symbol(Symbol *symbol) const
    {
        return _rules.find(symbol) != _rules.end();
    }

    // no more rules
    void freeze() const
    {
        // make sure at least one start rule
        if (!is_left_symbol(_w.get_start_symbol())) {
            throw std::runtime_error("missing at least one start rule");
        }
        // make sure each right hand nonterminal is defined
        for (RuleMap::value_type const &p: _rules) {
            Rule const *rule = p.second;
            for (RuleSymbol const &rule_symbol: rule->get_right_rule_symbols()) {
                Symbol *symbol = rule_symbol.get_symbol();
                if (!symbol->is_token()) {
                    if (_w.is_start_symbol(symbol)) {
                        throw std::runtime_error("start symbol on right hand side of rule");
                    }
                    if (!is_left_symbol(symbol)) {
                        std::ostringstream ss;
                        ss << "nonterminal " << symbol->get_name() << " is not defined";
                        throw std::runtime_error(ss.str()); 
                    }
                }
            }
        }
    }

  private:
    Workspace &_w;
    bool _enable_bypass; // true if option to bypass rules is enabled
    RuleMap _rules; // rules indexed by left hand symbol
};

} // basilcx

#hdr
#include <vector>
#include <map>
#end

#src
#include <basilcx_workspace.h>
#include <basilcx_rule.h>
#include <basilcx_rule_symbol.h>
#include <basilcx_symbol.h>
#include <basilcx_util.h>

#include <algorithm>
#include <sstream>
#end
