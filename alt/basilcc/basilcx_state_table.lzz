namespace basilcx {

class BaseKernel;
class FollowKernel;
class State;
class Workspace;

typedef std::vector<State *> StateVector;

class StateTable {
  public:
    StateTable()
    {}

    ~StateTable ()
    {
        for (StateMap::value_type const &p : _states) {
            delete p.second;
        }
    }

    // get state from follow kernel
    State *get_state(Workspace &w, FollowKernel *follow_kernel)
    {
        BaseKernel *base_kernel = follow_kernel->get_shift_kernel(w)->get_base_kernel(w);
        std::pair<StateMap::iterator, StateMap::iterator> p = _states.equal_range(base_kernel);
        for (StateMap::iterator i = p.first; i != p.second; ++i) {
            State *state = i->second;
            if (state->get_follow_kernel() == follow_kernel || is_kernel_equiv(w, state->get_follow_kernel(), follow_kernel)) {
                return state;
            }
        }
        State *state = _states.emplace_hint(p.second, base_kernel, new State(_states.size(), follow_kernel))->second;
        _pending.push_back(state);
        return state;
    }

    // get states ordered by number
    void get_states(StateVector &states) const
    {
        states.reserve(_states.size());
        for (StateMap::value_type const &p : _states) {
            states.push_back(p.second);
        }
        std::sort(states.begin(), states.end(), StateNumberLess());
    }

    // create states
    bool create_states(Workspace &w, int &num_conflicts, int &num_lex_state_conflicts)
    {
        num_conflicts = 0;
        num_lex_state_conflicts = 0;
        while (!_pending.empty()) {
            State *state = _pending.front();
            _pending.pop_front();
            num_conflicts += state->closure(w);
            if (state->get_lex_state().is_conflict()) {
                ++num_lex_state_conflicts;
            }
        }
        return num_conflicts == 0 && num_lex_state_conflicts == 0;
    }

  private:
    typedef std::multimap<BaseKernel *, State *> StateMap;
    StateMap _states;
    std::deque<State *> _pending; // new states pending finalize
};

namespace {

// true if kernels equivalent, produces the same moves
bool is_kernel_equiv(Workspace &w, FollowKernel *a_kernel, FollowKernel *b_kernel)
{
    // to avoid infinite loop
    std::set<BaseKernel *> history;
    // initialize pending
    typedef std::pair<FollowKernel *, FollowKernel *> FollowKernelPair;
    std::deque<FollowKernelPair> pending;
    pending.push_back(FollowKernelPair(a_kernel, b_kernel));
    while (!pending.empty()) {
        FollowKernelPair const &p = pending.front();
        FollowBase *a_follow_base = p.first->get_follow_base(w);
        FollowBase *b_follow_base = p.second->get_follow_base(w);
        pending.pop_front();
        if (a_follow_base->get_lazy_follow_move() != b_follow_base->get_lazy_follow_move() ||
                a_follow_base->get_lex_state() != b_follow_base->get_lex_state()) {
            return false;
        }
        if (history.insert(a_follow_base->get_shift_base()->get_base_kernel()).second) {
            FollowShiftMap const &a_shifts = a_follow_base->get_follow_shifts();
            FollowShiftMap const &b_shifts = b_follow_base->get_follow_shifts();
            for (FollowShiftMap::const_iterator i = a_shifts.begin(), endi = a_shifts.end(), j = b_shifts.begin(); i != endi; ++i, ++j) {
                if (i->second != j->second) {
                    pending.push_back(FollowKernelPair(i->second, j->second));
                }
            }
        }
    }
    return true;
}

// true if a state number < b state number
inline bool StateNumberLess(; State *a, State *b) const
{
    return a->_num < b->_num;
}

} // unamed
} // basilcx

#hdr
#include <deque>
#include <map>
#include <vector>
#end

#src
#include <basilcx_follow_base.h>
#include <basilcx_follow_kernel.h>
#include <basilcx_shift_base.h>
#include <basilcx_shift_kernel.h>
#include <basilcx_state.h>
#include <basilcx_util.h>
#include <basilcx_workspace.h>
#end
