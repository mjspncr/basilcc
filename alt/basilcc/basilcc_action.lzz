// basilcc action
//

namespace basilcc {

class State;
class Rule;
class Symbol;

class Action {
  public:
    inline Action()
      : _num(-1)
    {}

    virtual ~Action()
    {}

    virtual bool is_shift() const = 0;
    inline  bool is_reduction() const { return ! is_shift(); }

    int _num;
};

class ShiftAction : public Action {
  public:
    ShiftAction(State const *state)
        : _state(state)
    {}

    ~ ShiftAction()
    {}

    // true if shift
    bool is_shift() const
    {
        return true;
    }

    // get state
    inline State const *get_state() const
    {
        return _state;
    }

  private:
    // state on shift
    State const *_state;
};

// true if a < b
bool operator <(ShiftAction const &a, ShiftAction const &b)
{
    State const *a_state = a.get_state();
    State const *b_state = b.get_state();
    if (a_state != b_state) {
        return a_state < b_state;
    }
    return false;
}

class ReduceAction : public Action {
  public:
    ReduceAction(Rule const *rule, Symbol const *shortcut, bool accept)
        : _rule(rule), _shortcut(shortcut), _accept(accept)
    {}

    ~ReduceAction()
    {}

    // true if shift
    virtual bool is_shift() const
    {
        return false;
    }

    // get rule
    inline Rule const *get_rule() const
    {
        return _rule;
    }

    // get shortcut
    inline Symbol const *get_shortcut() const
    {
        return _shortcut;
    }

    // get shortcut number
    int get_shortcut_number() const
    {
      return _shortcut->get_number();
    }

    // true if has accept
    bool has_accept() const
    {
      return _accept;
    }

  private:
    // reduce on this rule
    Rule const *_rule;
    // shortcut
    Symbol const *_shortcut;
    // true if accept
    bool _accept;
};

// true if a < b 
bool operator <(ReduceAction const &a, ReduceAction const &b)
{
    Rule const *a_rule = a.get_rule();
    Rule const *b_rule = b.get_rule();
    if (a_rule != b_rule) {
        return a_rule < b_rule;
    }
    Symbol const *a_shortcut = a.get_shortcut();
    Symbol const *b_shortcut = b.get_shortcut();
    if (a_shortcut != b_shortcut) {
        return a_shortcut < b_shortcut;
    }
    return !a.has_accept() && b.has_accept();
}

bool operator <(Action const &a, Action const &b)
{
    bool a_is_shift = a.is_shift(), b_is_shift = b.is_shift();
    if (a_is_shift != b_is_shift) {
        return a_is_shift;
    }
    if (a_is_shift) {
        return static_cast<ShiftAction const &>(a) < static_cast<ShiftAction const &>(b);
    }
    return static_cast<ReduceAction const &>(a) < static_cast<ReduceAction const &>(b);
}

inline bool ActionLess(; Action const *a, Action const *b) const
{
    return *a < *b;
}

/*
// action to string
std::string actionToString (ActionPtr action)
{
    string str;
    if (action->isShift ())
    {
        ShiftAction const & shift_action = shiftAction (* action);
        str = "SHIFT";
        appendWithSpace (str, intToString (shift_action.getState ()->getNumber ()));
    }
    else
    {
        ReduceAction const & reduce_action = reduceAction (* action);
        RulePtr rule = reduce_action.getRule ();
        SymbolPtr shortcut = reduce_action.getShortcut ();
        if (rule->isStart ())
        {
            str = "DONE";
            appendWithSpace (str, intToString (rule->getNumber ()));
        }
        else
        {
            if (reduce_action.hasAccept ())
            {
                str = "ACCEPT";
            }
            else
            {
                str = "REDUCE";
            }
            appendWithSpace (str, intToString (rule->getNumber ()));
            appendWithSpace (str, shortcut->getName ());
        }
    }
    return str;
}

// append actions to string
void appendActions (std::string & str, ActionPtrVector const & actions)
{
    if (! actions.empty ())
    {
        for (ActionPtrVectorConstIter i = actions.begin (), endi = actions.end ();;) {
            str += actionToString (* i);
            if (++ i == endi) {
                break;
            }
            str += ", ";
        }
    }
}
*/

} // namespace basilcc


#hdr
#include <string>
#end

#src
#include <basilcc_rule.h>
#include <basilcc_state.h>
#include <basilcc_symbol.h>
#end
