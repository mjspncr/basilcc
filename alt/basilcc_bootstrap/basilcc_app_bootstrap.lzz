// basilcc_app_bootstrap
//


int main(int argc, char **argv)
{
    try {
#if 1
        Compiler c;
        bootstrap_grammar(c);
        int num_conflicts = 0;
        int num_lex_state_conflicts = 0;
        int num_states = c.compile(num_conflicts, num_lex_state_conflicts);
        std::cout << "num states: " << num_states << std::endl;
        std::cout << "num conflicts: " << num_conflicts << std::endl;
        std::cout << "num lex state conflicts: " << num_lex_state_conflicts << std::endl;

        c.parser_namespace = "basilcc_fe";
        c.userdata_class = "basilcc::Compiler";
        std::ofstream os("/home/mike/dev/basilcc/alt/basilcc/basilcc_fe_parser_fsm.lzz");
        serialize_fsm(c, os);
        print_states(c, "/home/mike/dev/basilcc/alt/basilcc_bootstrap/states.txt");
#else
        Compiler c;
        std::string filename = "/home/mike/dev/basilcc/alt/basilcc_bootstrap/basil_rules.txt";
        basilcc_fe::RuleLexer lexer(c, filename);
        basilcc_api::Parser<Compiler> parser(basilcc_fe::get_FSM(), lexer, c, basilcc_fe::get_nodes());
        parser.parse(0);
#endif
    }
    catch (std::exception const &e) {
        std::cerr << e.what() << std::endl;
        return 1;
    }
    return 0;
}

using namespace basilcc;

namespace
{
void bootstrap_grammar(Compiler &c)
{
    // [RootNode/void]
    // start -> rule-seq
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("rule-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
        };
        Node *node = c.get_node("RootNode");
        Rule *rule = c.add_rule(
            node, // node
            RuleSymbol(
                c.get_symbol("start"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
        node->define(rule, true, "void");
    }

    // rule-seq ->
    {
        c.add_rule(
            NULL, // node
            RuleSymbol(
                c.get_symbol("rule-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbolVector(), // right_rule_symbols
            RuleSymbolVector(), // explicit_follow
            false // no_bypass
        );
    }
    // [RuleSeqNode]
    // rule-seq -> rule-seq rule
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("rule-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("rule"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            )
        };
        Node *node = c.get_node("RuleSeqNode");
        Rule *rule = c.add_rule(
            node, // node
            RuleSymbol(
                c.get_symbol("rule-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
        node->define(rule, false);
    }

    // [RuleNode]
    // rule -> node-type symbol ARROW symbol-seq >
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("node-type"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("symbol"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("ARROW"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("symbol-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(1, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
        };
        Node *node = c.get_node("RuleNode");
        Rule *rule = c.add_rule(
            node,
            RuleSymbol(
                c.get_symbol("rule"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass

        );
        node->define(rule, false);

    }

    // node-type ->
    {
        c.add_rule(
            NULL, // node
            RuleSymbol(
                c.get_symbol("node-type"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbolVector(), // right_rule_symbols
            RuleSymbolVector(), // explicit_follow
            false // no_bypass
        );
    }
    // [NodeTypeNode]
    // node-type -> LBRACK IDENT node-qualifier RBRACK
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("LBRACK"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("IDENT"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("node-qualifier"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("RBRACK"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
        };
        Node *node = c.get_node("NodeTypeNode");
        Rule *rule = c.add_rule(
            NULL, // node
            RuleSymbol(
                c.get_symbol("node-type"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
        node->define(rule, false);
    }

    // node-qualifier ->
    {
        c.add_rule(
            NULL, // node
            RuleSymbol(
                c.get_symbol("node-qualifier"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbolVector(), // right_rule_symbols
            RuleSymbolVector(), // explicit_follow
            false // no_bypass
        );
    }
    // [NodeQualifierNode]
    // node-qualifier -> SLASH ident-opt
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("SLASH"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("ident-opt"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
        };
        Node *node = c.get_node("NodeQualifierNode");
        Rule *rule = c.add_rule(
            node,
            RuleSymbol(
                c.get_symbol("node-qualifier"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false // no_bypass
        );
        node->define(rule, false);
    }

    // ident-opt ->
    {
        c.add_rule(
            NULL, // node
            RuleSymbol(
                c.get_symbol("ident-opt"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbolVector(), // right_rule_symbols
            RuleSymbolVector(), // explicit_follow
            false // no_bypass
        );
    }        
    // ident-opt -> IDENT
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("IDENT"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            )
        };
        c.add_rule(
            NULL, // node
            RuleSymbol(
                c.get_symbol("ident-opt"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
    }

    // symbol-seq ->
    {
        c.add_rule(
            NULL, // node
            RuleSymbol(
                c.get_symbol("symbol-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbolVector(), // right_rule_symbols
            RuleSymbolVector(), // explicit_follow
            false // no_bypass
        );
    }
    // [SymbolSeqNode]
    // symbol-seq -> symbol-seq symbol
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("symbol-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("symbol"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            )
        };
        Node *node = c.get_node("SymbolSeqNode");
        Rule *rule = c.add_rule(
            node,
            RuleSymbol(
                c.get_symbol("symbol-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
        node->define(rule, false);
    }

    // [SymbolNode]
    // symbol <* -> IDENT attrib-seq
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("IDENT"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
        };
        Node *node = c.get_node("SymbolNode");
        Rule *rule =c.add_rule(
            node,
            RuleSymbol(
                c.get_symbol("symbol"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                true, // sticky
                true  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
        node->define(rule, false);
    }
    
    // [AttribSeq1Node/Attributes]
    // attrib-seq ->
    {
        Node *node = c.get_node("AttribSeq1Node");
        Rule *rule = c.add_rule(
            node,
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbolVector(), // right_rule_symbols
            RuleSymbolVector(), // explicit_follow
            false // no_bypass
        );
        node->define(rule, true, "Attributes");
    }        
    // [AttribSeq2Node/Attributes]
    // attrib-seq -> attrib-seq NUMBER
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("NUMBER"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            )
        };
        Node *node = c.get_node("AttribSeq2Node");
        Rule *rule = c.add_rule(
            node,
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
        node->define(rule, true, "Attributes");
    }
    // [AttribSeq3Node/Attributes]
    // attrib-seq -> attrib-seq LT
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("LT"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            )
        };
        Node *node = c.get_node("AttribSeq3Node");
        Rule *rule = c.add_rule(
            node,
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
        node->define(rule, true, "Attributes");
    }
    // [AttribSeq4Node/Attributes]
    // attrib-seq -> attrib-seq STAR
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("STAR"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            )
        };
        Node *node = c.get_node("AttribSeq4Node");
        Rule *rule = c.add_rule(
            node,
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
        node->define(rule, true, "Attributes");
    }
    // [AttribSeq5Node/Attributes]
    // attrib-seq -> attrib-seq PLUS bang-seq
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("PLUS"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("bang-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            )
        };
        Node *node = c.get_node("AttribSeq5Node");
        Rule *rule = c.add_rule(
            node,
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
        node->define(rule, true, "Attributes");
    }
    // [AttribSeq6Node/Attributes]
    // attrib-seq -> attrib-seq CARET bang-seq
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("CARET"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("bang-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            )
        };
        Node *node = c.get_node("AttribSeq6Node");
        Rule *rule = c.add_rule(
            node,
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
        node->define(rule, true, "Attributes");
    }
    // [AttribSeq7Node/Attributes]
    // attrib-seq -> attrib-seq GT bang-seq
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("GT"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("bang-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            )
        };
        Node *node = c.get_node("AttribSeq7Node");
        Rule *rule = c.add_rule(
            node,
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
        node->define(rule, true, "Attributes");
    }

    // [BangSeq1Node/int]
    // bang-seq ->
    {
        Node *node = c.get_node("BangSeq1Node");
        Rule *rule = c.add_rule(
            node,
            RuleSymbol(
                c.get_symbol("bang-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbolVector(), // right_rule_symbols
            RuleSymbolVector(), // explicit_follow
            false // no_bypass
        );
        node->define(rule, true, "int");
    }
    // [BangSeq2Node/int]
    // bang-seq -> bang-seq BANG
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("bang-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("BANG"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            )
        };
        Node *node = c.get_node("BangSeq2Node");
        Rule *rule = c.add_rule(
            node,
            RuleSymbol(
                c.get_symbol("bang-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
        node->define(rule, true, "int");
    }
}

} // unnamed

#src
#include <basilcc_compiler.h>
#include <basilcc_rule.h>
#include <basilcc_node.h>
#include <basilcc_print_states.h>
#include <basilcc_serialize_fsm.h>

#include <basilcc_fe_lexer.h>
#include <basilcc_fe_parser_fsm.h>
#include <basilcc_api_parser.h>

#include <iostream>
#include <fstream>
#end
