// basilcc temp follow move

namespace basilcc {

class Compiler;

class TempFollowMove {
  public:
    TempFollowMove()
    {}

    ~TempFollowMove()
    {
        delete_objects(_temp_moves);
    }

    // get temp moves
    inline TempMoveVector const &get_temp_moves() const
    {
        return _temp_moves;
    }

    // add reduction
    void add_reduction(Rule const *rule, Follow const &follow, Priority const &priority, bool sticky, bool accept)
    {
        for (FollowItem const &follow_item: follow.get_follow_items()) { 
            TempMove const *temp_move = get_temp_move(follow_item.get_token());
            temp_move->add_reduction(
                rule,
                follow_item.get_shortcut(),
                follow_item.get_reduce_priority() + priority,
                follow_item.has_sticky() || sticky,
                follow_item.has_accept() || accept);
        }
    }

    // add shift
    void add_shift(Symbol const *term, Priority const &priority)
    {
        // add shift to priority action
        TempMove const *temp_move = get_temp_move(term);
        temp_move->add_shift(priority);
    }

    // freeze, no more changes to moves
    void freeze()
    {
        // freeze temp moves (sort and trim)
        for (TempMove *temp_move: _temp_moves) {
            temp_move->freeze();
        }
    }

    // return lazy follow move
    LazyFollowMove const *get_lazy_follow_move(Compiler &c) const
    {
        // get the default move
        TempMove const *def_temp_move = 0;
        TempMoveVector local_temp_moves(_temp_moves);
        // todo: option for no default action
        /*
        if (!c.no_default_actions())
        */
        {
            // partition so that ones that can be default are at end
            TempMoveVector::iterator p = std::partition(local_temp_moves.begin(), local_temp_moves.end(), temp_move_cannot_be_default);
            if (p != local_temp_moves.end()) {
                // got some, sort just those and find one that occurs the most
                std::sort(p, local_temp_moves.end(), temp_move_default_less);
                pair<TempMoveVector::iterator, TempMoveVector::iterator> r = most(p, local_temp_moves.end(), temp_move_default_same);
                def_temp_move = *r.first;
                // and discard them
                local_temp_moves.erase(r.first, r.second);
            }
        }
        // get lazy moves
        LazyMoveVector lazy_moves;
        for (TempMove const *temp_move: local_temp_moves) {
            lazy_moves.push_back (temp_move->get_lazy_move(c));
        }
        // sort lazy moves then get lazy move sel
        std::sort(lazy_moves.begin(), lazy_moves.end(), lazy_move_less);
        LazyMoveSel const *lazy_move_sel = c.get_lazy_move_sel(lazy_moves);
        // get default lazy action seq
        LazyActionSeq const *def_lazy_action_seq = NULL;
        if (def_temp_move) {
            // get lazy action seq from default priority move
            def_lazy_action_seq = def_temp_move->get_lazy_action_seq(c);
        }
        else {
            // get empty saction list
            LazyActionVector lazy_actions;
        def_lazy_action_seq = getLazyActionSeq (cc, lazy_actions);
      }
      // return lazy follow move from table
      return basilcc::getLazyFollowMove (cc, lazy_move_sel, def_lazy_action_seq);
    }

    // get conflicts, may take actions, so make sure is called after getLazyFollowMove
    void getConflicts (ConflictPtrVector & conflicts)
    {
      for_each (m_temp_moves.begin (), m_temp_moves.end (), GetConflicts (conflicts));
    }

  private:
    // get temp_move for token, create if doesn't exist
    TempMovePtr getTempMove (SymbolPtr token)
    {
      // search for term move
      for (TempMovePtrVectorConstIter i = m_temp_moves.begin (); i != m_temp_moves.end (); ++ i)
      {
        TempMovePtr temp_move = * i;
        if (temp_move->getToken () == token)
        {
          return temp_move;
        }
      }
      TempMovePtr temp_move = new TempMove (token);
      m_temp_moves.push_back (temp_move);
      return temp_move;
    }

  private:
    // priority move set
    TempMovePtrVector m_temp_moves;
  }
}

using namespace std;

#hdr
#include <basilcc/conflict_ptr_vector.h>
#include <basilcc/follow_ptr.h>
#include <basilcc/lazy_follow_move_ptr.h>
#include <basilcc/priority.h>
#include <basilcc/rule_ptr.h>
#include <basilcc/symbol_ptr.h>
#include <basilcc/temp_follow_move_ptr.h>
#include <basilcc/temp_move_ptr_vector.h>
#end

#src
#include <basilcc/first.h>
#include <basilcc/follow.h>
#include <basilcc/follow_item.h>
#include <basilcc/lazy_action_seq_api.h>
#include <basilcc/lazy_follow_move_api.h>
#include <basilcc/lazy_move.h>
#include <basilcc/lazy_move_sel_api.h>
#include <basilcc/symbol.h>
#include <basilcc/temp_move.h>
#include <basilcc/util.h>
#include <algorithm>
#end
