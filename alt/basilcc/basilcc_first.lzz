// basil_first
//
// symbol first set
//

namespace basilcc {

class ShiftRule;

typedef std::vector<FirstItem> FirstItemVector;
typedef std::vector<ShiftRule const *> ShiftRuleVector;
typedef std::set<FirstItem> FirstItemSet;

class First
{
  public:
    First ()
      : _null(false)
    {}

    ~ First()
    {}

    // set null
    void set_null()
    {
        _null = true;
    }

    // update lex state
    void update(LexState const &lex_state)
    {
        _lex_state.update(lex_state);
    }

    // update first item
    void update(Symbol const *token, Priority const &shift_priority)
    {
        std::pair<FirstItemSet::iterator, bool> r = _first_items.insert(FirstItem(token, shift_priority));
        if (!r.second) {
            // update shift priority of existing item, modifying set item is safe
            // as the order depends only on the token
            const_cast<FirstItem&>(*r.first).update(shift_priority);
        }
    }

    // freeze, no more first items
    void freeze()
    {}

    // true if set has null
    inline bool has_null() const
    {
        return _null;
    }

    // get lex state
    inline LexState const &get_lex_state() const
    {
        return _lex_state;
    }

    // get first items
    inline FirstItemSet const &get_first_items() const
    {
        return _first_items;
    }

    // set shift rules, steals rules
    inline void set_shift_rules(ShiftRuleVector &shift_rules)
    {
        _shift_rules.swap(shift_rules);
    }

    // get shift rules
    inline ShiftRuleVector const &get_shift_rules() const
    {
        return _shift_rules;
    }

  private:
    FirstItemSet _first_items;
    bool _null; // true if first set has null
    LexState _lex_state;
    ShiftRuleVector _shift_rules;
};

} // basilcc

#hdr
#include <basilcc_first_item.h>
#include <basilcc_lex_state.h>
#include <vector>
#include <set>
#end

#src
#end
