// basilcc lazy action sequence

namespace basilcc {

class ActionSeq;
class Compiler;
class LazyAction;
class Shift;
class Symbol;
typedef std::vector<LazyAction const *> LazyActionVector;
typedef std::vector<Shift> ShiftVector;

class LazyActionSeq {
  public:
    LazyActionSeq(LazyActionVector const &lazy_actions)
        : _lazy_actions(lazy_actions)
    {}

    ~LazyActionSeq()
    {}

    // get lazy actions
    inline LazyActionVector const &get_lazy_actions() const
    {
        return _lazy_actions;
    }

    // get action seq
    ActionSeq const *get_action_seq(Compiler &c, ShiftVector const &token_shifts, Symbol const *token) const
    {
        ActionVector actions;
        actions.reserve(_lazy_actions.size());
        for (LazyAction const *lazy_action: _lazy_actions) {
            actions.push_back(lazy_action->get_action(c, token_shifts, token));
        }
        return c.get_action_seq(actions);
    }

  private:
    LazyActionVector _lazy_actions;
};

bool operator<(LazyActionSeq const &a, LazyActionSeq const &b)
{
    LazyActionVector const &a_lazy_actions = a.get_lazy_actions();
    LazyActionVector const &b_lazy_actions = b.get_lazy_actions();
    if (a_lazy_actions.size() != b_lazy_actions.size()) {
        return a_lazy_actions.size() < b_lazy_actions.size();
    }
    return a_lazy_actions < b_lazy_actions; // OK to compare pointers
}

} // namespace basilcc

#hdr
#include <vector>
#include <map>
#end

#src
#include <basilcc_compiler.h>
#include <basilcc_lazy_action.h>
#end
