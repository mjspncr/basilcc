// basilcc lazy action
//

namespace basilcc {

class Compiler;
class Rule;
class State;
class Symbol;

typedef std::map<Symbol const *, State const *> ShiftMap;

class LazyAction {
  public:
    LazyAction() 
    {}

    virtual ~LazyAction()
    {}

    // true if shift
    virtual bool is_shift() const
    {
        return false;
    }
    // true if reduction
    inline bool is_reduction() const
    {
      return !is_shift();
    }

    // get action
    virtual Action const *get_action(Compiler &c, ShiftMap const &token_shifts, Symbol const *token) const = 0;
};

class ShiftLazyAction : public LazyAction {
  public:
    ShiftLazyAction() 
    {}

    ~ShiftLazyAction()
    {}

    // true if shift
    bool is_shift() const
    {
        return true;
    }

    // get action
    Action const *get_action(Compiler &c, ShiftMap const &token_shifts, Symbol const *token) const
    {
        ShiftMap::const_iterator p = token_shifts.find(token);
        std::assert(p != token_shifts.end());
        return c.get_shift_action(p->second);
    }
};

// reduce
class ReduceLazyAction : public LazyAction {
  public:
    ReduceLazyAction(Rule const *rule, Symbol const *shortcut, bool accept)
        : _rule(rule), _shortcut(shortcut), _accept(accept)
    {}

    ~ReduceLazyAction()
    {}

    // get rule
    inline Rule const *get_rule() const
    {
        return _rule;
    }

    // get shortcut
    inline Symbol const *get_shortcut() const
    {
        return _shortcut;
    }

    // true if has accept
    inline bool has_accept() const
    {
        return _accept;
    }

    // get action
    Action const *get_action(Compilier &c, ShiftMap const &token_shifts, Symbol const *token) const
    {
        return c.get_reduce_action(_rule, _shortcut, _accept);
    }

  private:
    Rule const *_rule;
    Symbol const *_shortcut;
    bool _accept;
};

} // namespace basilcc

#hdr
#include <map>
#end

#src
#include <basilcc_compiler.h>
#include <cassert>
#end
