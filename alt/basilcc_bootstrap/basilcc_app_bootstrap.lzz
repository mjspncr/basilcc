// basilcc_app_bootstrap
//


int main(int argc, char **argv)
{
    try {
#if 1
        Compiler c;
        bootstrap_grammar(c);
        int num_conflicts = 0;
        int num_lex_state_conflicts = 0;
        int num_states = c.compile(num_conflicts, num_lex_state_conflicts);
        std::cout << "num states: " << num_states << std::endl;
        std::cout << "num conflicts: " << num_conflicts << std::endl;
        std::cout << "num lex state conflicts: " << num_lex_state_conflicts << std::endl;

        c.parser_namespace = "basilcc_fe";
        c.userdata_class = "basilcc::Compiler";
        std::ofstream os("/home/mike/dev/basilcc/alt/basilcc/basilcc_fe_parser_fsm.lzz");
        serialize_fsm(c, os);
        print_states(c, "/home/mike/dev/basilcc/alt/basilcc_bootstrap/states.txt");
#else
        Compiler c;
        std::string filename = "/home/mike/dev/basilcc/alt/basilcc_bootstrap/basil_rules.txt";
        basilcc_fe::RuleLexer lexer(c, filename);
        basilcc_api::Parser<Compiler> parser(basilcc_fe::get_FSM(), lexer, c, basilcc_fe::get_nodes());
        parser.parse(0);
#endif
    }
    catch (std::exception const &e) {
        std::cerr << e.what() << std::endl;
        return 1;
    }
    return 0;
}

using namespace basilcc;

namespace
{
void bootstrap_grammar(Compiler &c)
{
    // start -> rule-seq-opt
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("rule-seq-opt"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
        };
        c.add_rule(
            NULL, // node
            RuleSymbol(
                c.get_symbol("start"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
    }
    // rule-seq-opt ->
    {
        c.add_rule(
            NULL, // node
            RuleSymbol(
                c.get_symbol("rule-seq-opt"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbolVector(), // right_rule_symbols
            RuleSymbolVector(), // explicit_follow
            false // no_bypass
        );
    }
    // rule-seq-opt -> rule-seq
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("rule-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            )
        };
        c.add_rule(
            NULL, // node
            RuleSymbol(
                c.get_symbol("rule-seq-opt"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
    }
    // rule-seq -> rule
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("rule"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            )
        };
        c.add_rule(
            NULL, // node
            RuleSymbol(
                c.get_symbol("rule-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
    }
    // rule-seq -> rule-seq rule
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("rule-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("rule"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            )
        };
        c.add_rule(
            NULL, // node
            RuleSymbol(
                c.get_symbol("rule-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
    }
    // rule [RuleNode] -> symbol node-type-opt ARROW symbol-seq-opt >
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("symbol"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("node-type-opt"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("ARROW"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("symbol-seq-opt"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(1, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
        };
        Node *node = c.get_node("RuleNode");
        Rule *rule = c.add_rule(
            node,
            RuleSymbol(
                c.get_symbol("rule"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
        node->define(rule, true); // has semantics

    }
    // node-type-opt ->
    {
        c.add_rule(
            NULL, // node
            RuleSymbol(
                c.get_symbol("node-type-opt"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbolVector(), // right_rule_symbols
            RuleSymbolVector(), // explicit_follow
            false // no_bypass
        );
    }
    // node-type-opt -> node-type
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("node-type"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            )
        };
        c.add_rule(
            NULL, // node
            RuleSymbol(
                c.get_symbol("node-type-opt"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
    }
    // node-type [NodeTypeNode] -> LBRACK IDENT RBRACK
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("LBRACK"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("IDENT"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("RBRACK"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
        };
        Node *node = c.get_node("NodeTypeNode");
        Rule *rule = c.add_rule(
            node,
            RuleSymbol(
                c.get_symbol("node-type"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
        node->define(rule, false);
    }
    // symbol-seq-opt ->
    {
        c.add_rule(
            NULL, // node
            RuleSymbol(
                c.get_symbol("symbol-seq-opt"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbolVector(), // right_rule_symbols
            RuleSymbolVector(), // explicit_follow
            false // no_bypass
        );
    }
    // symbol-seq-opt -> symbol-seq
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("symbol-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            )
        };
        c.add_rule(
            NULL, // node
            RuleSymbol(
                c.get_symbol("symbol-seq-opt"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
    }
    // symbol-seq [SymbolSeq1Node] -> symbol
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("symbol"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            )
        };
        Node *node = c.get_node("SymbolSeq1Node");
        Rule *rule = c.add_rule(
            node,
            RuleSymbol(
                c.get_symbol("symbol-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
        node->define(rule, false);
    }
    // symbol-seq [SymbolSeq2Node] -> symbol-seq symbol
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("symbol-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("symbol"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
        };
        Node *node = c.get_node("SymbolSeq2Node");
        Rule *rule = c.add_rule(
            node,
            RuleSymbol(
                c.get_symbol("symbol-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
        node->define(rule, false);
    }
    // symbol <* [SymbolNode] -> IDENT attrib-seq
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("IDENT"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
        };
        Node *node = c.get_node("SymbolNode");
        Rule *rule =c.add_rule(
            node,
            RuleSymbol(
                c.get_symbol("symbol"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                true, // sticky
                true  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
        node->define(rule, false);
    }
    // attrib-seq [AttribSeq1Node] ->
    {
        Node *node = c.get_node("AttribSeq1Node");
        Rule *rule = c.add_rule(
            node,
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbolVector(), // right_rule_symbols
            RuleSymbolVector(), // explicit_follow
            false // no_bypass
        );
        node->define(rule, false);
    }        
    // attrib-seq [AttribSeq2Node] -> attrib-seq NUMBER
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("NUMBER"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            )
        };
        Node *node = c.get_node("AttribSeq2Node");
        Rule *rule = c.add_rule(
            node,
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
        node->define(rule, false);
    }
    // attrib-seq [AttribSeq3Node] -> attrib-seq LT
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("LT"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            )
        };
        Node *node = c.get_node("AttribSeq3Node");
        Rule *rule = c.add_rule(
            node,
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
        node->define(rule, false);
    }
    // attrib-seq [AttribSeq4Node] -> attrib-seq STAR
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("STAR"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            )
        };
        Node *node = c.get_node("AttribSeq4Node");
        Rule *rule = c.add_rule(
            node,
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
        node->define(rule, false);
    }
    // attrib-seq [AttribSeq5Node] -> attrib-seq PLUS  bang-seq-opt
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("PLUS"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("bang-seq-opt"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            )
        };
        Node *node = c.get_node("AttribSeq5Node");
        Rule *rule = c.add_rule(
            node,
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
        node->define(rule, false);
    }
    // attrib-seq [AttribSeq6Node] -> attrib-seq CARET bang-seq-opt
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("CARET"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("bang-seq-opt"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            )
        };
        Node *node = c.get_node("AttribSeq6Node");
        Rule *rule = c.add_rule(
            node,
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
        node->define(rule, false);
    }
    // attrib-seq [AttribSeq7Node] -> attrib-seq GT bang-seq-opt
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("GT"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("bang-seq-opt"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            )
        };
        Node *node = c.get_node("AttribSeq7Node");
        Rule *rule = c.add_rule(
            node,
            RuleSymbol(
                c.get_symbol("attrib-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
        node->define(rule, false);
    }
    // bang-seq-opt ->
    {
        c.add_rule(
            NULL, // node
            RuleSymbol(
                c.get_symbol("bang-seq-opt"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbolVector(), // right_rule_symbols
            RuleSymbolVector(), // explicit_follow
            false // no_bypass
        );
    }
    // bang-seq-opt -> bang-seq
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("bang-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            )
        };
        c.add_rule(
            NULL, // node
            RuleSymbol(
                c.get_symbol("bang-seq-opt"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
    }
    // bang-seq [BangSeq1Node] -> BANG
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("BANG"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            )
        };
        Node *node = c.get_node("BangSeq1Node");
        Rule *rule = c.add_rule(
            node,
            RuleSymbol(
                c.get_symbol("bang-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
        node->define(rule, false);
    }
    // bang-seq [BangSeq2Node] -> bang-seq BANG
    {
        RuleSymbolVector right_rule_symbols {
            RuleSymbol(
                c.get_symbol("bang-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            RuleSymbol(
                c.get_symbol("BANG"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            )
        };
        Node *node = c.get_node("BangSeq2Node");
        Rule *rule = c.add_rule(
            node,
            RuleSymbol(
                c.get_symbol("bang-seq"),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(0, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            ),
            right_rule_symbols,
            RuleSymbolVector(), // explicit_follow
            false  // no_bypass
        );
        node->define(rule, false);
    }
}
}

#src
#include <basilcc_compiler.h>
#include <basilcc_rule.h>
#include <basilcc_node.h>
#include <basilcc_print_states.h>
#include <basilcc_serialize_fsm.h>

#include <basilcc_fe_lexer.h>
#include <basilcc_fe_parser_fsm.h>
#include <basilcc_api_parser.h>

#include <iostream>
#include <fstream>
#end
