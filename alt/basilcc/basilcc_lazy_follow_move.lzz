// basilcc lazy follow move

namespace basilcc {

class Compiler;
class LazyActionSeq;
class LazyMoveSel;
class Shift;
class StateMove;
typedef std::vector<Shift> ShiftVector;

class LazyFollowMove {
  public:
    LazyFollowMove(LazyMoveSel const *lazy_move_sel, LazyActionSeq const *def_lazy_action_seq)
        : _lazy_move_sel(lazy_move_sel), _def_lazy_action_seq(def_lazy_action_seq)
    {}

    ~LazyFollowMove()
    {}

    // get lazy move selection
    inline LazyMoveSel const *get_lazy_move_sel() const
    {
        return _lazy_move_sel;
    }

    // get default lazy action sequence
    inline LazyActionSeq const *get_default_lazy_action_seq() const
    {
        return _def_lazy_action_seq;
    }

    // get state move
    StateMove const *get_state_move(Compiler &c, ShiftVector const &token_shifts) const
    {
        MoveSel const *move_sel = _lazy_move_sel->get_move_sel(c, token_shifts);
        ActionSeq const *def_action_seq = _def_lazy_action_seq->get_action_seq(c, token_shifts, NULL);
        return c.get_state_move(move_sel, def_action_seq);
    }
    
  private:
    LazyMoveSel const *_lazy_move_sel;
    LazyActionSeq const *_def_lazy_action_seq;
};

// a < b, compares pointers
bool operator<(LazyFollowMove const &a, LazyFollowMove const &b)
{
    if (a.get_lazy_move_sel() != b.get_lazy_move_sel()) {
        return a.get_lazy_move_sel() < b.get_lazy_move_sel();
    }
    return a.get_default_lazy_action_seq() < b.get_default_lazy_action_seq();
}

} // basilcc

#hdr
#include <vector>
#end

#src
#include <basilcc_compiler.h>
#include <basilcc_lazy_action_seq.h>
#include <basilcc_lazy_move_sel.h>
#end
