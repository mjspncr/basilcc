// basilcc_app_bootstrap
//


int main(int argc, char **argv)
{
    try {
#if 1
        Workspace w;
        Bootstrap(w).grammar();
        int num_conflicts = 0;
        int num_lex_state_conflicts = 0;
        int num_states = compile_fsm(w, num_conflicts, num_lex_state_conflicts);
        std::cout << "num states: " << num_states << std::endl;
        std::cout << "num conflicts: " << num_conflicts << std::endl;
        std::cout << "num lex state conflicts: " << num_lex_state_conflicts << std::endl;
        print_states(w, "/home/mike/dev/basilcc/alt/basilcc_bootstrap/states.txt");
        w.fsm_namespace = "basilcp";
        w.usertype = "basilcx::Workspace";
        w.usercode << "namespace basilcx {\n";
        w.usercode << "    class Workspace;\n";
        w.usercode << "}\n";
        std::ofstream os("/home/mike/dev/basilcc/alt/basilcc/basilcp_fsm.lzz");
        serialize_fsm(w, os);
#else
        Compiler c;
        std::string filename = "/home/mike/dev/basilcc/alt/basilcc_bootstrap/basil_rules.txt";
        basilcc_fe::RuleLexer lexer(c, filename);
        basilcc_api::Parser<Compiler> parser(basilcc_fe::get_FSM(), lexer, c, basilcc_fe::get_nodes());
        parser.parse(0);
#endif
    }
    catch (std::exception const &e) {
        std::cerr << e.what() << std::endl;
        return 1;
    }
    return 0;
}

using namespace basilcx;

namespace
{
class Bootstrap(Workspace &w) {
  public:
    void grammar()
    {
        // [RootNode/void]
        // start -> rule-seq
        {
            Node *node = get_node("RootNode");
            Rule *rule = add_rule(
                node,
                symbol("start"), symbol("rule-seq")
            );
            node->define(rule, true, "void");
        }
        // rule-seq ->
        {
            add_rule(NULL, symbol("rule-seq"));
        }
        // [RuleSeqNode]
        // rule-seq -> rule-seq rule
        {
            Node *node = get_node("RuleSeqNode");
            Rule *rule = add_rule(
                node,
                symbol("rule-seq"), symbol("rule-seq"), symbol("rule")
            );
            node->define(rule, false);
        }
        // [RuleNode]
        // rule -> node-type symbol ARROW symbol-seq >
        {
            Node *node = get_node("RuleNode");
            Rule *rule = add_rule(
                node,
                symbol("rule"), symbol("node-type"), symbol("symbol"), symbol("ARROW"), symbol("symbol-seq", 1)
            );
            node->define(rule, false);
        }
        // node-type ->
        {
            add_rule(
                NULL,
                symbol("node-type")
            );
        }
        // [NodeTypeNode]
        // node-type -> LBRACK IDENT node-qualifier RBRACK
        {
            Node *node = get_node("NodeTypeNode");
            Rule *rule = add_rule(
                node,
                symbol("node-type"), symbol("LBRACK"), symbol("IDENT"), symbol("node-qualifier"), symbol("RBRACK")
            );
            node->define(rule, false);
        }
        // node-qualifier ->
        {
            add_rule(
                NULL,
                symbol("node-qualifier")
            );
        }
        // [NodeQualifierNode]
        // node-qualifier -> SLASH ident-opt
        {
            Node *node = get_node("NodeQualifierNode");
            Rule *rule = add_rule(
                node,
                symbol("node-qualifier"), symbol("SLASH"), symbol("ident-opt")
            );
            node->define(rule, false);
        }
        // ident-opt ->
        {
            add_rule(
                NULL,
                symbol("ident-opt")
            );
        }        
        // ident-opt -> IDENT
        {
            add_rule(
                NULL,
                symbol("ident-opt"), symbol("IDENT")
            );
        }
        // symbol-seq ->
        {
            add_rule(
                NULL,
                symbol("symbol-seq")
            );
        }
        // [SymbolSeqNode]
        // symbol-seq -> symbol-seq symbol
        {
            Node *node = get_node("SymbolSeqNode");
            Rule *rule = add_rule(
                node,
                symbol("symbol-seq"), symbol("symbol-seq"), symbol("symbol")
            );
            node->define(rule, false);
        }
        // [SymbolNode]
        // symbol <* -> IDENT attrib-seq
        {
            Node *node = get_node("SymbolNode");
            Rule *rule = add_rule(
                node,
                symbol("symbol"), symbol("IDENT"), symbol("attrib-seq")
            );
            node->define(rule, false);
        }
        // [AttribSeq1Node/Attributes]
        // attrib-seq ->
        {
            Node *node = get_node("AttribSeq1Node");
            Rule *rule = add_rule(
                node,
                symbol("attrib-seq")
            );
            node->define(rule, true, "Attributes");
        }
        // [AttribSeq2Node/Attributes]
        // attrib-seq -> attrib-seq NUMBER
        {
            Node *node = get_node("AttribSeq2Node");
            Rule *rule = add_rule(
                node,
                symbol("attrib-seq"), symbol("attrib-seq"), symbol("NUMBER")
            );
            node->define(rule, true, "Attributes");
        }
        // [AttribSeq3Node/Attributes]
        // attrib-seq -> attrib-seq LT
        {
            Node *node = get_node("AttribSeq3Node");
            Rule *rule = add_rule(
                node,
                symbol("attrib-seq"), symbol("attrib-seq"), symbol("LT")
            );
            node->define(rule, true, "Attributes");
        }
        // [AttribSeq4Node/Attributes]
        // attrib-seq -> attrib-seq STAR
        {
            Node *node = get_node("AttribSeq4Node");
            Rule *rule = add_rule(
                node,
                symbol("attrib-seq"), symbol("attrib-seq"), symbol("STAR")
            );
            node->define(rule, true, "Attributes");
        }
        // [AttribSeq5Node/Attributes]
        // attrib-seq -> attrib-seq PLUS bang-seq
        {
            Node *node = get_node("AttribSeq5Node");
            Rule *rule = add_rule(
                node,
                symbol("attrib-seq"), symbol("attrib-seq"), symbol("PLUS"), symbol("bang-seq")
            );
            node->define(rule, true, "Attributes");
        }
        // [AttribSeq6Node/Attributes]
        // attrib-seq -> attrib-seq CARET bang-seq
        {
            Node *node = get_node("AttribSeq6Node");
            Rule *rule = add_rule(
                node,
                symbol("attrib-seq"), symbol("attrib-seq"), symbol("CARET"), symbol("bang-seq")
            );
            node->define(rule, true, "Attributes");
        }
        // [AttribSeq7Node/Attributes]
        // attrib-seq -> attrib-seq GT bang-seq
        {
            Node *node = get_node("AttribSeq7Node");
            Rule *rule = add_rule(
                node,
                symbol("attrib-seq"), symbol("attrib-seq"), symbol("GT"), symbol("bang-seq")
            );
            node->define(rule, true, "Attributes");
        }
        // [BangSeq1Node/int]
        // bang-seq ->
        {
            Node *node = get_node("BangSeq1Node");
            Rule *rule = add_rule(
                node,
                symbol("bang-seq")
            );
            node->define(rule, true, "int");
        }
        // [BangSeq2Node/int]
        // bang-seq -> bang-seq BANG
        {
            Node *node = get_node("BangSeq2Node");
            Rule *rule = add_rule(
                node,
                symbol("bang-seq"), symbol("BANG")
            );
            node->define(rule, true, "int");
            node->define(rule, true, "int");
        }
    }
    
    RuleSymbol symbol(char const *name, int shift_priority = 0)
    {
        return
            RuleSymbol(
                w.get_symbol(name),
                Priority(0, 0), // reduce
                Priority(0, 0), // first
                Priority(shift_priority, 0), // shift
                LexState(),
                false, // sticky
                false  // accept
            );
    }

    Node *get_node(char const *name)
    {
        return w.nodes.get_node(name);
    }

    Rule *add_rule(
        Node *node,
        RuleSymbol const &left_symbol,
        RuleSymbolVector const &right_symbols)
    {
        return w.add_rule(node, left_symbol, right_symbols, RuleSymbolVector(), false);
    }
    Rule *add_rule(
        Node *node,
        RuleSymbol const &left_symbol)
    {
        return add_rule(node, left_symbol, RuleSymbolVector()); 
    }
    Rule *add_rule(
        Node *node,
        RuleSymbol const &left_symbol,
        RuleSymbol const &right_symbol1)
    {
        RuleSymbolVector right_symbols {right_symbol1};
        return add_rule(node, left_symbol, right_symbols); 
    }
    Rule *add_rule(
        Node *node,
        RuleSymbol const &left_symbol,
        RuleSymbol const &right_symbol1,
        RuleSymbol const &right_symbol2)
    {
        RuleSymbolVector right_symbols {right_symbol1, right_symbol2};
        return add_rule(node, left_symbol, right_symbols); 
    }
    Rule *add_rule(
        Node *node,
        RuleSymbol const &left_symbol,
        RuleSymbol const &right_symbol1,
        RuleSymbol const &right_symbol2,
        RuleSymbol const &right_symbol3)
    {
        RuleSymbolVector right_symbols {right_symbol1, right_symbol2, right_symbol3};
        return add_rule(node, left_symbol, right_symbols); 
    }
    Rule *add_rule(
        Node *node,
        RuleSymbol const &left_symbol,
        RuleSymbol const &right_symbol1,
        RuleSymbol const &right_symbol2,
        RuleSymbol const &right_symbol3,
        RuleSymbol const &right_symbol4)
    {
        RuleSymbolVector right_symbols {right_symbol1, right_symbol2, right_symbol3, right_symbol4};
        return add_rule(node, left_symbol, right_symbols); 
    }
    Rule *add_rule(
        Node *node,
        RuleSymbol const &left_symbol,
        RuleSymbol const &right_symbol1,
        RuleSymbol const &right_symbol2,
        RuleSymbol const &right_symbol3,
        RuleSymbol const &right_symbol4,
        RuleSymbol const &right_symbol5)
    {
        RuleSymbolVector right_symbols {right_symbol1, right_symbol2, right_symbol3, right_symbol4, right_symbol5};
        return add_rule(node, left_symbol, right_symbols); 
    }
};

} // unnamed

#src
#include <basilcx_workspace.h>
#include <basilcx_rule.h>
#include <basilcx_node.h>
#include <basilcx_print_states.h>
#include <basilcx_serialize_fsm.h>
#include <basilcx_compile_fsm.h>

//#include <basilcc_fe_lexer.h>
//#include <basilcc_fe_parser_fsm.h>
//#include <basilcc_api_parser.h>

#include <iostream>
#include <fstream>
#end
