namespace basilcx {

class Conflict;
class FollowKernel;
class FollowRule;
class LazyFollowMove;
class ShiftBase;
class Symbol;
class Workspace;
typedef std::map<Symbol *, FollowKernel *> FollowShiftMap;
typedef std::vector<FollowRule *> FollowRuleVector;
typedef std::vector<Conflict *> ConflictVector;

class FollowBase {
  public:
    FollowBase(Workspace &w, ShiftBase *shift_base, FollowRuleVector const &kernel_rules)
        : _shift_base(shift_base)
    {
        _lazy_follow_move = init_follow_base(w, _shift_base, kernel_rules, _lex_state, _follow_shifts, _conflicts);
    }

    ~FollowBase()
    {
        delete_objects(_conflicts);
    }

    // get shift base
    inline ShiftBase *get_shift_base() const
    {
        return _shift_base;
    }

    // get lex state
    inline LexState const &get_lex_state() const
    {
        return _lex_state;
    }

    // get follow shifts
    inline FollowShiftMap const &get_follow_shifts() const
    {
        return _follow_shifts;
    }   

    // get lazy follow move
    inline LazyFollowMove *get_lazy_follow_move() const
    {
        return _lazy_follow_move;
    }

    // true if has conflicts
    inline bool has_conflicts() const
    {
        return !_conflicts.empty ();
    }

    // get conflicts
    inline ConflictVector const &get_conflicts() const
    {
        return _conflicts;
    }

  private:
    ShiftBase *_shift_base;
    LexState _lex_state;
    FollowShiftMap _follow_shifts;
    LazyFollowMove *_lazy_follow_move;
    ConflictVector _conflicts; // follow base owns conflicts
};

namespace {

// initialize follow base, set lex_state, follow_shifts, conflics and return lazy follow move
LazyFollowMove *init_follow_base(
    Workspace &w,
    ShiftBase *shift_base,
    FollowRuleVector const &kernel_rules,
    LexState &lex_state,
    FollowShiftMap &follow_shifts,
    ConflictVector &conflicts)
{
    // can get lex state from kernel rules
    FollowRuleVector const &kernel_rules = kernel.get_follow_rules();
    for (FollowRule *follow_rule : kernel_rules) {
        lex_state.update(follow_rule->get_lex_state());
    }
    FollowRuleVector follow_rules;
    get_follow_rules(w, shift_base, kernel_rules, follow_rules);
    get_follow_shifts(w, follow_rules, follow_shifts);
    return get_lazy_follow_move(w, follow_rules, conflicts);
}    

// get all follow rules, kernel and non-kernel 
void get_follow_rules(Workspace &w, ShiftBase *shift_base, FollowRuleVector const &kernel_rules, FollowRuleVector &follow_rules)
{
    FollowRulePtrMap non_kernel_rule_ptrs;
    for (ShiftRule *shift_rule : shift_base->get_non_kernel_rules()) {
        non_kernel_rule_ptrs.emplace(shift_rule->get_left_symbol(), FollowRulePtr(new FollowRule(shift_rule)));
    }
    FollowBaseHelper(kernel_rules, non_kernel_rule_ptrs).run();
    follow_rules.reserve(kernel_rules.size() + non_kernel_rule_ptrs.size());
    follow_rules = kernel_rules;
    for (FollowRulePtrMap::value_type &p : non_kernel_rule_ptrs) {
        follow_rules.push_back(w.follow_rules.freeze_follow_rule(p.second));
    }
}

// follow base helper, updates non kernel rules
typedef std::multimap<Symbol *, FollowRulePtr> FollowRulePtrMap;
class FollowBaseHelper(FollowRuleVector const &kernel_rules, FollowRulePtrMap const &non_kernel_rules)
{
  public:
    // update non kernel rules
    void run()
    {
        for (FollowRule *follow_rule: kernel_rules) {
            update(follow_rule);
        }
    }

  private:
    void update(FollowRule *follow_rule)
    {
        BaseRule const *base_rule = follow_rule->get_shift_rule()->get_base_rule();
        if (!base_rule->is_reduction()) {
            Symbol *next_symbol = base_rule->get_next_symbol();
            if (!next_symbol->is_token()) {
                Follow follow;
                follow_rule->get_next_follow(follow);
                std::pair<FollowRulePtrMap::const_iterator, FollowRulePtrMap::const_iterator> r = non_kernel_rules.equal_range(next_symbol);
                for (FollowRulePtrMap::const_iterator i = r.first; i != r.second; ++i) {
                    FollowRule *next_follow_rule = i->second.get();
                    if (next_follow_rule->update(follow)) {
                        update(next_follow_rule);
                    }
                }
            }
        }
    }
};

// get follow shifts
void get_follow_shifts(Workspace &w, FollowRuleVector const &follow_rules, FollowShiftMap &follow_shifts)
{
    for (FollowRuleVector::const_iterator i = follow_rules.begin(), endi = follow_rules.end(); i != endi; ++i) {
        FollowRule *follow_rule = *i; 
        BaseRule *base_rule = follow_rule->get_shift_rule()->get_base_rule();
        if (!base_rule->is_reduction() && !base_rule->get_rule()->can_bypass()) {
            Symbol *next_symbol = base_rule->get_next_symbol();
            std::pair<FollowShiftMap::iterator, bool> r = follow_shifts.emplace(next_symbol, (FollowKernel *)NULL);
            if (r.second) {
                // new kernel, get all rules, only need to search from i+1
                FollowRuleVector kernel_rules(1, follow_rule->get_next_follow_rule(w));
                for (FollowRuleVector::const_iterator j = i; ++j != endi;) {
                    follow_rule = *j;
                    base_rule = follow_rule->get_shift_rule()->get_base_rule();
                    if (!base_rule->is_reduction() && base_rule->get_next_symbol() == next_symbol && !base_rule->get_rule()->can_bypass()) {
                        kernel_rules.push_back(follow_rule->get_next_follow_rule(w));
                    }
                }
                r.first->second = w.follow_kernels.get_follow_kernel(kernel_rules);
            }
        }
    }
}

// get lazy follow move
LazyFollowMove const *get_lazy_follow_move(Workspace &w, FollowRuleVector const &follow_rules, ConflictVector &conflicts)
{
    TempFollowMove temp_follow_move;
    for (FollowRule *follow_rule: follow_rules) {
      ShiftRule *shift_rule = follow_rule->get_shift_rule();
      BaseRule *base_rule = shift_rule->get_base_rule();
      if (base_rule->is_reduction()) {
          // add reduction (except if rule is bypassed)
          Rule *rule = base_rule->get_rule();
          if (!rule->can_bypass()) {
              RuleSymbol const &left_rule_symbol = rule->get_left_rule_symbol();
              Priority priority = left_rule_symbol.get_reduce_priority();
              bool accept = left_rule_symbol.has_accept();
              bool sticky = left_rule_symbol.has_sticky();
              Follow const &follow = follow_rule->get_follow();
              temp_follow_move.add_reduction(rule, follow, priority, accept, sticky);
          }
      }
      else
      {
          // add shift if next symbol is a token
          Symbol *symbol = base_rule->get_next_symbol();
          if (symbol->is_token()) {
              Priority priority = shift_rule->get_shift_priority() + base_rule->get_shift_priority();
              temp_follow_move.add_shift(symbol, priority);
          }
      }
    }
    return temp_follow_move.get_lazy_follow_move(w, conflicts);
}

} // unnamed
} // basilcx

#hdr
#include <basilcx_lex_state.h>

#include <map>
#include <vector>
#end

#src
#include <basilcx_base_rule.h>
#include <basilcx_conflict.h>
#include <basilcx_follow_rule.h>
#include <basilcx_rule.h>
#include <basilcx_shift_base.h>
#include <basilcx_shift_rule.h>
#include <basilcx_symbol.h>
#include <basilcx_temp_follow_move.h>
#include <basilcx_util.h>
#include <basilcx_workspace.h>
#end
