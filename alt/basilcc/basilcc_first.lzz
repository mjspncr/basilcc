// basil_first
//
// symbol first set
//

namespace basilcc {


typedef std::vector<FirstItem> FirstItemVector;
typedef std::set<FirstItem> FirstItemSet;

class First
{
  public:
    First ()
      : _null(false)
    {}

    ~ First()
    {}

    // set null
    void set_null()
    {
        _null = true;
    }

    // update lex state
    void update(LexState const &lex_state)
    {
        _lex_state.update(lex_state);
    }

    // update first item
    void update(Symbol *token, Priority const &shift_priority)
    {
        std::pair<FirstItemSet::iterator, bool> r = _first_items.insert(FirstItem(token, shift_priority));
        if (!r.second) {
            // update shift priority of existing item, modifying set item is safe
            // as the order depends only on the token
            const_cast<FirstItem&>(*r.first).update(shift_priority);
        }
    }

    // freeze, no more first items
    void freeze()
    {}

    // true if set has null
    inline bool has_null() const
    {
        return _null;
    }

    // get lex state
    inline LexState const &get_lex_state() const
    {
        return _lex_state;
    }

    // get first items
    inline FirstItemSet const &get_first_items() const
    {
        return _first_items;
    }

    std::string to_string() const
    {
        std::ostringstream ss;
        if (_lex_state.is_set()) {
            ss << _lex_state.to_string() << ' ';
        }
        if (_null) {
            ss << "null ";
        }
        for (FirstItemSet::const_iterator i = _first_items.begin(), endi = _first_items.end();;) {
            ss << (*i).to_string();
            if (++i == endi) {
                break;
            }
            ss << ' ';
        }
        return ss.str();
    }

  private:
    FirstItemSet _first_items;
    bool _null; // true if first set has null
    LexState _lex_state;
};

} // basilcc

#hdr
#include <basilcc_first_item.h>
#include <basilcc_lex_state.h>
#include <vector>
#include <set>
#end

#src
#include <sstream>
#end
