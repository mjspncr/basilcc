// basilcc_node_table
//
// maintains all nodes
//

namespace basilcc {

class Node;

bool NodeLess(; Node const *a, Node const *b) const { return *a < *b; }
typedef std::set<Node *, NodeLess> NodeSet;

class NodeTable
{
  public:
    NodeTable()
    {}

    ~NodeTable()
    {
        delete_objects(_nodes); 
    }

    // get node with name, create new node if doesn't exist
    Node *get_node(char const *name)
    {
        std::unique_ptr<Node> node_ptr(new Node(name));
        std::pair<NodeSet::iterator, bool> r = _nodes.insert(node_ptr.get());
        if (r.second) {
            node_ptr.release();
        }
        return *r.first;
    }

    // freeze nodes, no more
    void freeze_nodes()
    {
        // order by name, just nice for generated code
        std::vector<Node *> nodes(_nodes.begin(), _nodes.end());
        std::sort(nodes.begin(), nodes.end(), NodeNameLess());
        // make sure each is defined and assign number
        int k = 0;
        for (Node *node: nodes) {
            if (!node->is_defined()) {
                std::ostringstream ss;
                ss << "node " << node->get_name() << " does not have a defining rule";
                throw std::runtime_error(ss.str());
            }
            const_cast<int &>(node->_num) = k ++;
        }
    }

  private:
    NodeSet _nodes;
};

} // basilcc

#hdr
#include <set>
#end

#src
#include <basilcc_node.h>
#include <basilcc_util.h>
#include <algorithm>
#include <memory>
#include <sstream>
#end
