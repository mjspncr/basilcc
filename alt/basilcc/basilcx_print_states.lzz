namespace basilcx {

class Workspace;
class State;

// print state
void print_state(State *state, std::ostream &os)
{
    // state number followed by lex state if non-zero
    os << state->_num;
    LexState lex_state = state->get_lex_state();
    if (lex_state.is_conflict()) {
      os << " (LEXICAL STATE CONFLICT)";
    }
    else if (lex_state.is_set())
    {
      os << " (" << lex_state.get_state() << ')';
    }
    os << "\n-----\n";
    // conflicts
    FollowKernel *follow_kernel = state->get_follow_kernel();
    FollowBase *follow_base = follow_kernel->get_follow_base();
    ConflictVector const &conflicts = follow_base->get_conflicts();
    if (!conflicts.empty()) {
        os << "CONFLICT\n"; // TODO - show conflict
    }
    {
        FollowRuleVector const &follow_rules = follow_kernel->get_follow_rules();
        for (FollowRule *follow_rule : follow_rules) {
            ShiftRule *shift_rule = follow_rule->get_shift_rule();
            BaseRule *base_rule = shift_rule->get_base_rule();
            os << base_rule->to_string() << ' ';
            os << follow_rule->get_follow().to_string(base_rule->get_left_symbol()) << '\n';
        }
    }

    /*
    // rules
    BaseKernel const &base_kernel = follow_base.get_shift_base().get_base_kernel();
    for (BaseRule const *base_rule: base_kernel.get_base_rules()) {
        os << base_rule->to_string() << '\n';
    }
    */
    
    os << '\n';
    StateMove *state_move = state->get_state_move();
    MoveVector const &moves = state_move->get_move_sel()->get_moves();
    ActionVector const &def_actions = state_move->get_default_action_seq()->get_actions();
    if (!(moves.empty() && def_actions.empty())) {
        for (Move *move : moves) {
            move->format(os);
            os << '\n';
        }
        if (!def_actions.empty()) {
            os << "* - ";
            format_actions(def_actions, os);
            os << '\n';
        }
    }
    ShiftSel *nonterm_shift_sel = state->get_nonterm_shift_sel();
    if (nonterm_shift_sel) {
        os << '\n';
        for (Shift const &shift : nonterm_shift_sel->get_shifts()) {
            os << shift.get_symbol()->get_name() << " - GOTO " << shift.get_state()->_num << '\n';
        }
    }
    os << '\n';
}

// print states to stream
void print_states(Workspace &w, std::ostream &os)
{
    StateVector states;
    w.states.get_states(states);
    for (State *state : states) {
        print_state(state, os);
    }
}

// print states to file
void print_states(Workspace &c, std::string const &filename)
{
    std::ofstream os(filename.c_str (), std::ios_base::out);
    if (!os) {
        throw std::runtime_error("failed to open file for writing");
    }
    print_states(c, os);
}

} // basilcc

#hdr
#include <iosfwd>
#include <string>
#end

#src
#include <basilcx_action.h>
#include <basilcx_action_seq.h>
#include <basilcx_base_kernel.h>
#include <basilcx_base_rule.h>
#include <basilcx_follow_base.h>
#include <basilcx_follow_kernel.h>
#include <basilcx_follow_rule.h>
#include <basilcx_move.h>
#include <basilcx_move_sel.h>
#include <basilcx_shift_rule.h>
#include <basilcx_shift_sel.h>
#include <basilcx_state.h>
#include <basilcx_state_move.h>
#include <basilcx_symbol.h>
#include <basilcx_workspace.h>

#include <fstream>
#end
