// basilcc temp follow move

namespace basilcc {

class Compiler;
class Conflict;
class Follow;
class LazyFollowMove;
class Rule;
class Symbol;
class TempMove;
typedef std::vector<Conflict *> ConflictVector;

class TempFollowMove {
  public:
    TempFollowMove()
    {}

    ~TempFollowMove()
    {
        for (TempMoveMap::value_type &p: _temp_moves) {
            delete p.second;
        }
    }

    // add reduction
    void add_reduction(Rule const *rule, Follow const &follow, Priority const &priority, bool sticky, bool accept)
    {
        for (FollowItem const &follow_item: follow.get_follow_items()) {
            TempMove *temp_move = get_temp_move(follow_item.get_token());
            temp_move->add_reduction(
                rule,
                follow_item.get_shortcut(),
                follow_item.get_reduce_priority() + priority,
                follow_item.has_sticky() || sticky,
                follow_item.has_accept() || accept);
        }
    }

    // add shift
    void add_shift(Symbol const *term, Priority const &priority)
    {
        // add shift to priority action
        TempMove *temp_move = get_temp_move(term);
        temp_move->add_shift(priority);
    }

    // get conflicts and return lazy follow move
    LazyFollowMove const *get_lazy_follow_move(Compiler &c, ConflictVector &conflicts) const
    {
        // get the default move
        typedef std::vector<TempMove *> TempMoveVector;
        TempMoveVector temp_moves;
        temp_moves.reserve(_temp_moves.size());
        for (TempMoveMap::value_type const &p: _temp_moves) {
            TempMove *temp_move = p.second;
            temp_move->freeze();
            temp_moves.push_back(temp_move);
        }
        // partition so that ones that can be default are at end
        TempMove *def_temp_move = NULL;
        TempMoveVector::iterator p = std::partition(temp_moves.begin(), temp_moves.end(), temp_move_can_not_be_default);
        if (p != temp_moves.end()) {
            // got some, sort just those and find one that occurs the most
            std::sort(p, temp_moves.end(), temp_move_default_less);
            std::pair<TempMoveVector::iterator, TempMoveVector::iterator> r = most(p, temp_moves.end(), temp_move_default_same);
            def_temp_move = *r.first;
            temp_moves.erase(r.first, r.second);
        }
        // get lazy moves
        LazyMoveVector lazy_moves;
        lazy_moves.reserve(temp_moves.size());
        for (TempMove const *temp_move: temp_moves) {
            lazy_moves.push_back(temp_move->get_lazy_move(c));
        }
        // sort lazy moves by token then get lazy move sel
        std::sort(lazy_moves.begin(), lazy_moves.end(), LazyMoveTokenLess());
        LazyMoveSel const *lazy_move_sel = c.get_lazy_move_sel(lazy_moves);
        // get default lazy action seq
        LazyActionSeq const *def_lazy_action_seq = 0;
        if (def_temp_move) {
            def_lazy_action_seq = def_temp_move->get_lazy_action_seq(c);
        }
        else {
            LazyActionVector lazy_actions;
            def_lazy_action_seq = c.get_lazy_action_seq(lazy_actions);
        }

        // get conflicts will steal actions, so must be after getting lazy moves
        for (TempMove *temp_move: temp_moves) {
            temp_move->get_conflicts(conflicts);
        }
        if (def_temp_move) {
            def_temp_move->get_conflicts(conflicts);
        }

        return c.get_lazy_follow_move(lazy_move_sel, def_lazy_action_seq);
    }

  private:
    // get temp_move for token, create if doesn't exist
    TempMove *get_temp_move(Symbol const *token)
    {
        std::pair<TempMoveMap::iterator, bool> r = _temp_moves.emplace(token, (TempMove *)NULL);
        if (r.second) {
            r.first->second = new TempMove(token);
        }
        return r.first->second;
    }

  private:
    typedef std::map<Symbol const *, TempMove *> TempMoveMap;
    TempMoveMap _temp_moves;
};

namespace {

// true if token less in lazy move, used to sort lazy moves, does NOT compare pointers
bool LazyMoveTokenLess(; LazyMove const *a, LazyMove const *b) const
{
    return *a->get_token() < *b->get_token();
}

} // unnamed
} // basilcc

#hdr
#include <basilcc_priority.h>
#include <map>
#include <vector>
#end

#src
#include <basilcc_compiler.h>
#include <basilcc_first.h>
#include <basilcc_follow.h>
#include <basilcc_follow_item.h>
#include <basilcc_lazy_move.h>
#include <basilcc_symbol.h>
#include <basilcc_temp_move.h>
#include <basilcc_util.h>
#include <algorithm>
#end
