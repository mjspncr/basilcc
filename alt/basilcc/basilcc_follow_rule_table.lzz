// basilcc_follow_rule_table
//
// maintains follow rules
// 

namespace basilcc {

class Follow;
class FollowRule;
class ShiftRule;
typedef std::unique_ptr<FollowRule> FollowRulePtr;

class FollowRuleTable
{
  public:
    FollowRuleTable()
    {}
      
    ~FollowRuleTable()
    {
        delete_objects(_follow_rules);
    }

    // freeze follow rule
    FollowRule const *freeze_follow_rule(FollowRulePtr &follow_rule)
    {
        std::pair<FollowRuleSet::iterator, bool> r = _follow_rules.insert(follow_rule.get());
        if (r.second) {
            follow_rule.release();
        }
        return *r.first;
    }

    // get follow rule from shift rule and follow
    FollowRule const *get_follow_rule(ShiftRule const *shift_rule, Follow const &follow)
    {
        FollowRulePtr follow_rule(new FollowRule(shift_rule, follow));
        return freeze_follow_rule(follow_rule);
    }

  private:
    bool FollowRuleLess(; FollowRule const *a, FollowRule const *b) const { return *a < *b; }
    typedef std::set<FollowRule const *, FollowRuleLess> FollowRuleSet;
    FollowRuleSet _follow_rules;
};

} // basilcc

#hdr
#include <set>
#include <memory>
#end

#src
#include <basilcc_follow_rule.h>
#include <basilcc_util.h>
#end
