namespace basilcx {

class First;
typedef std::set<FollowItem> FollowItemSet;

class Follow
{
  public:
    Follow()
    {}

    ~Follow()
    {}

    // update, return true if changed
    bool update(Follow const &follow)
    {
      bool changed = false;
      for (FollowItem const &item: follow.get_follow_items()) {
          std::pair<FollowItemSet::iterator, bool> r = _follow_items.insert(item);
          if (r.second || const_cast<FollowItem&>(*r.first).update(item.get_reduce_priority(), item.has_sticky(), item.has_accept())) {
              changed = true;
          }
      }
      if (_lex_state.update(follow.get_lex_state())) {
          changed = true;
      }
      return changed;
    }

    // add follow with shortcut and flags
    void add_follow(Follow const &follow, Symbol *shortcut, Priority const &rp, bool sticky, bool accept)
    {
      for (FollowItem const &item: follow.get_follow_items()) {
          FollowItemSet::iterator p = _follow_items.insert(FollowItem(item.get_token(), shortcut)).first;
          const_cast<FollowItem &>(*p).update(rp, sticky, accept);
      }
      _lex_state.update(follow.get_lex_state());
    }

    // add follow w/o shortcut
    void add_follow(Follow const &follow, Priority const &rp, bool sticky, bool accept)
    {
      for (FollowItem const &item: follow.get_follow_items()) {
          FollowItemSet::iterator p = _follow_items.insert(FollowItem(item.get_token(), item.get_shortcut())).first;
          const_cast<FollowItem &>(*p).update(rp, sticky, accept);
      }
      _lex_state.update(follow.get_lex_state());
    }

    // add first
    void add_first(First const &first, LexState const &lex_state, Symbol *shortcut, Priority const &rp, bool sticky, bool accept)
    {
        for (FirstItem const &item: first.get_first_items()) {
          FollowItemSet::iterator p = _follow_items.insert(FollowItem(item.get_token(), shortcut)).first;
          const_cast<FollowItem &>(*p).update(rp + item.get_first_priority(), sticky, accept);
        }
        _lex_state.update(lex_state);
        _lex_state.update(first.get_lex_state());
    }

    // get follow items
    inline FollowItemSet const &get_follow_items() const
    {
        return _follow_items;
    }

    // get lex state
    inline LexState const &get_lex_state() const
    {
        return _lex_state;
    }

    // to string, to cut down on clutter suppress shortcut if equal to left hand symbol in rule
    std::string to_string(Symbol *left_symbol) const
    {
        std::string items_str;
        if (_lex_state.is_set()) {
            items_str = _lex_state.to_string();
        }
        append_with_space(items_str, follow_items_to_string(_follow_items, left_symbol));
        std::string str = "[";
        str += items_str;
        str += ']';
        return str;
    }

  private:
    FollowItemSet _follow_items;
    LexState _lex_state;
};

// true if a < b
bool operator<(Follow const &a, Follow const &b)
{
    FollowItemSet const &a_items = a.get_follow_items();
    FollowItemSet const &b_items = b.get_follow_items();
    if (a_items.size() != b_items.size()) {
        return a_items.size() < b_items.size();
    }
    return a_items < b_items;
}

namespace {

// return follow items as string
std::string follow_items_to_string(FollowItemSet const &follow_items, Symbol *left_symbol)
{
    std::ostringstream ss;
    for (FollowItemSet::const_iterator i = follow_items.begin(), endi = follow_items.end();;) {
        ss << i->to_string(left_symbol);
        if (++ i == endi) {
            break;
        }
        ss << ' ';
    }
    return ss.str();
}

} // unnamed
} // basilcx

#hdr
#include <basilcx_follow_item.h>
#include <basilcx_lex_state.h>

#include <set>
#end

#src
#include <basilcx_first.h>
#include <basilcx_util.h>

#include <sstream>
#end
