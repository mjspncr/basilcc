// basilcc temp action, just for ordering by priority
//

namespace basilcc {

class Compiler;
class Rule;
class Symbol;
class LazyAction;

class TempAction {
  public:
    TempAction(Priority const &priority)
        : _priority(priority)
    {}

    virtual ~TempAction()
    {}

    // true if shift
    virtual bool is_shift() const = 0;

    // true if reduction
    inline bool is_reduction () const
    {
        return !is_shift();
    }
    
    // get priority
    inline Priority const &get_priority() const
    {
        return _priority;
    }

    // update priority, take max
    void update(Priority const &priority)
    {
        _priority = max_priority(_priority, priority);
    }

    // get lazy action
    virtual LazyAction const *get_lazy_action(Compiler &c) const = 0;

  private:
    Priority _priority;
};

class ShiftTempAction : public TempAction {
  public:
    ShiftTempAction(Priority const &priority)
        : TempAction(priority)
    {}

    ~ShiftTempAction()
    {}

    // true if shift
    bool is_shift() const
    {
        return true;
    }

    // get lazy action
    LazyActionPtr get_lazy_action(Compiler &c) const
    {
        return c.get_shift_lazy_action();
    }
};

class ReduceTempAction : public TempAction {
  public:
    ReduceTempAction(Rule const *rule, Symbol const *shortcut, Priority const &priority, bool sticky, bool accept)
        : TempAction(priority), _rule(rule), _shortcut(shortcut), _sticky(sticky), _accept(accept)
    {}

    ~ReduceTempAction()
    {}

    // true if shift
    bool is_shift () const
    {
        return false;
    }

    // get rule
    inline Rule const *get_rule() const
    {
        return _rule;
    }

    // get shortcut
    inline Symbol const *get_shortcut() const
    {
        return _shortcut;
    }

    // true if has sticky
    inline bool has_sticky() const
    {
        return _sticky;
    }

    // true if has accept
    inline bool has_accept () const
    {
        return _accept;
    }

    // update, max priority and stick and accept if either are true
    void update(Priority const &priority, bool sticky, bool accept)
    {
        TempAction::update(priority);
        _sticky = _sticky || sticky;
        _accept = _accept || accept;
    }

    // get lazy action
    LazyAction const *get_lazy_action(Compiler &c) const
    {
        // TODO
        //return c.get_reduce_lazy_action(_rule, _shortcut, _accept);
    }

  private:
    Rule const *_rule;
    Symbol const *_shortcut;
    bool _sticky;
    bool _accept;
};

// a < b
bool operator <(TempAction const &a, TempAction const &b)
{
    bool result = false;
    int count_a = a.get_priority().get_count();
    int count_b = b.get_priority().get_count();
    if (count_a != count_b) {
        return count_a > count_b;
    }
    // conflict: just sort consistently then
    if (a.is_reduction() != b.is_reduction()) {
        return a.is_shift();
    }
    // both reductions, sort by rule
    ReduceTempAction const &c = static_cast<ReduceTempAction const &>(a);
    ReduceTempAction const &d = static_cast<ReduceTempAction const &>(b);
    if (c.get_rule() != d.get_rule()) {
        return *c.get_rule() < *d.get_rule();
    }
    // sort by shortcut
    return *c.get_shortcut() < d.get_shortcut();
}
inline bool TempActionLess(; TempAction const *a, TempAction const *b) const
{
    return *a < *b;
}

// a == b
bool operator ==(TempAction const &a, TempAction const &b)
{
    // equal if priority count is equal
    return a.get_priority().get_count() == b.get_priority().get_count();
}
inline bool operator !=(TempAction const &a, TempAction const &b)
{
    return !(a == b);
}

// a == b
// or: can a replace b?
bool operator ==(ReduceTempAction const &a, ReduceTempAction const &b)
{
    // same if only rule and shortcut are same
    bool result = false;
    if (a.getRule () == b.getRule () && a.getShortcut () == b.getShortcut ()) {
      result = true;
      // if accepting on b but not on a, then a can't replace b
      // this will happen if b is sticky--b won't be considered in default set
      if (b.has_accept() && !a.has_accept()) {
        result = false;
      }
    }
    return result;
}

// a < b
bool operator <(ReduceTempAction const &a, ReduceTempAction const &b)
{
    if (a.get_rule() != b.get_rule()) {
        return *a.get_rule() < *b.get_rule();
    }
    if (a.get_shortcut() != b.get_shortcut()) {
        return *a.get_shortcut() < *b.get_shortcut();
    }
    return a.has_accept() && !b.has_accept();
}

/*
// temp action to string
std::string tempActionToString (TempActionPtr temp_action)
{
    string str;
    if (temp_action->isShift ())
    {
        str = "SHIFT";
        appendWithSpace (str, shiftPriorityToString (temp_action->getPriority ()));
    }
    else
    {
        ReduceTempAction const & r_temp_action = static_cast <ReduceTempAction const &> (* temp_action);
        RulePtr rule = r_temp_action.getRule ();
        SymbolPtr shortcut = r_temp_action.getShortcut ();
        if (rule->isStart ())
        {
            str = "DONE";
            appendWithSpace (str, intToString (rule->getNumber ()));
        }
        else
        {
            if (r_temp_action.hasAccept ())
            {
                str = "ACCEPT";
            }
            else
            {
                str = "REDUCE";
            }
            appendWithSpace (str, intToString (rule->getNumber ()));
            appendWithSpace (str, shortcut->getName ());
        }
        appendWithSpace (str, firstPriorityToString (temp_action->getPriority ()));
    }
    return str;
}

// append tmp actions to string, comma separated
void appendTempActions (std::string & str, TempActionPtrVector const & temp_actions)
{
    if (! temp_actions.empty ())
    {
        for (TempActionPtrVectorConstIter i = temp_actions.begin (), endi = temp_actions.end ();;)
        {
            str += tempActionToString (* i);
            if (++ i == endi)
            {
                break;
            }
            str += ", ";
        }
    }
}
*/

} // basilcc

#hdr
#include <basilcc_priority.h>
#end

#src
#include <basilcc_compiler.h>
#include <basilcc_rule.h>
#include <basilcc_symbol.h>
#end
