// basilcc_state
//
// basilcc parser tables, maintains all state
//

namespace basilcc {

class Action;
class ActionSeq;
class Move;
typedef std::vector<Action const *> ActionVector;

class Compiler {
  public:
    Compiler()
        : _symbols(*this), _rules(*this)
    {}

    // intern std::string, return shared char const *
    inline char const *intern(std::string const &str)
    {
      return _strings.insert(str).first->c_str ();
    }

    //
    // symbols
    //

    // get symbol from name, new symbol if doesn't exist
    inline Symbol *get_symbol(std::string const &name)
    {
        return _symbols.get_symbol(intern(name));
    }

    // get special symbols
    inline Symbol const *get_eot_symbol() const
    {
        return _symbols.get_eot_symbol();
    }
    inline Symbol const *get_start_symbol() const
    {
        return _symbols.get_start_symbol();
    }
    inline bool is_start_symbol(Symbol const *symbol) const
    {
        return symbol == get_start_symbol();
    }

    //
    // rules
    //

    // add new rule
    inline void add_rule(
        Node const *node,
        RuleSymbol const &left_rule_symbol,
        RuleSymbolVector const &right_rule_symbols,
        RuleSymbolVector const &explicit_follow,
        bool no_bypass
    )
    {
        _rules.add_rule(
            node,
            left_rule_symbol,
            right_rule_symbols,
            explicit_follow,
            no_bypass
        );
    }

    // get all rules
    inline RuleVector const &get_rules() const
    {
        return _rules.get_rules();
    }
    // get rules with left hand symbol
    inline RuleVector const &get_rules(Symbol const *left_symbol) const
    {
        return _rules.get_rules(left_symbol);
    }

    // get base rule
    inline BaseRule const *get_base_rule(Rule *rule, int pos)
    {
        return _base_rules.get_base_rule(rule, pos);
    }

    // freeze shift rule, return shared frozen rule
    inline ShiftRule const *freeze_shift_rule(ShiftRulePtr &shift_rule)
    {
        return _shift_rules.freeze_shift_rule(shift_rule);
    }
    // get frozen shift rule from components
    inline ShiftRule const *get_shift_rule(BaseRule const *base_rule, Priority const &sp)
    {
        return _shift_rules.get_shift_rule(base_rule, sp);
    }

    // kernels

    // get base kernel from kernel shift rules, steals rules
    inline BaseKernel const *get_base_kernel(BaseRuleVector &base_rules)
    {
        return _base_kernels.get_base_kernel(base_rules);
    }


    // actions
    inline Action const *get_shift_action(State const *state)
    {
        return _actions.get_shift_action(state);
    }
    inline Action const *get_reduce_action(Rule const *rule, Symbol const *shortcut, bool accept)
    {
        return _actions.get_reduce_action(rule, shortcut, accept);
    }

    // action seqs
    inline ActionSeq const *get_action_seq(ActionVector &actions) // steals actions
    {
        return _action_seqs.get_action_seq(actions);
    }

    // moves
    inline Move const *get_move(Symbol const *token, ActionSeq const *action_seq)
    {
        return _moves.get_move(token, action_seq);
    }
    
    // move sels
    inline MoveSel const *get_move_sel(MoveVector &moves) // steals moves
    {
        return _move_sels.get_move_sel(moves);
    }

    // lazy actions
    inline LazyAction const *get_shift_lazy_action()
    {
        return _lazy_actions.get_shift_lazy_action();
    }
    inline LazyAction const *get_reduce_lazy_action(Rule const *rule, Symbol const *shortcut, bool accept)
    {
        return _lazy_actions.get_reduce_lazy_action(rule, shortcut, accept);
    }

    // lazy moves
    inline LazyMove const *get_lazy_move(Symbol const *token, LazyActionSeq const *lazy_action_seq)
    {
        return _lazy_moves.get_lazy_move(token, lazy_action_seq);
    }

  private:
    // cached strings
    std::set<std::string> _strings;
    // tables
    SymbolTable _symbols;
    NodeTable _nodes;
    RuleTable _rules;
    BaseRuleTable _base_rules;
    ShiftRuleTable _shift_rules;
    FollowRuleTable _follow_rules;
    BaseKernelTable _base_kernels;
    ShiftKernelTable _shift_kernels;

    ActionTable _actions;
    ActionSeqTable _action_seqs;
    MoveTable _moves;
    MoveSelTable _move_sels;
    LazyActionTable _lazy_actions;
    LazyMoveTable _lazy_moves;
};

} // basilcc

#hdr
#include <basilcc_action_seq_table.h>
#include <basilcc_action_table.h>
#include <basilcc_base_kernel_table.h>
#include <basilcc_base_rule_table.h>
#include <basilcc_follow_rule_table.h>
#include <basilcc_lazy_action_table.h>
#include <basilcc_lazymove_table.h>
#include <basilcc_move_sel_table.h>
#include <basilcc_move_table.h>
#include <basilcc_node_table.h>
#include <basilcc_rule_table.h>
#include <basilcc_shift_kernel_table.h>
#include <basilcc_shift_rule_table.h>
#include <basilcc_symbol_table.h>
#include <string>
#include <set>
#end
