// basilcc_rule_table
//
// maintains all rules
//

namespace basilcc {

class Node;
class Compiler;
class Symbol;
class Rule;
typedef std::vector<RuleSymbol> RuleSymbolVector;
typedef std::vector<Rule *> RuleVector;

class RuleTable
{
  public:
    RuleTable(Compiler &c)
        : _c(c)
    {
        _enable_bypass = false; // TODO: read from config
    }

    ~RuleTable()
    {
        delete_objects(_rules);
    }

    // add new rule
    void add_rule(
        Node const *node,
        RuleSymbol const &left_rule_symbol,
        RuleSymbolVector const &right_rule_symbols,
        RuleSymbolVector const &explicit_follow,
        bool no_bypass
    )
    {
        Symbol const *left_symbol = left_rule_symbol.get_symbol();
        if (!left_symbol->is_token()) {
            std::ostringstream ss;
            ss << "left hand symbol '" << left_symbol->get_name() << "' is a token";
            throw std::runtime_error(ss.str());
        }
        bool is_start = _c.is_start_symbol(left_symbol);
        bool can_bypass = false;
        // can bypass rule on reduction if only one nonterminal on right hand side and no node
        if (_enable_bypass && !no_bypass && !node) {
            if (right_rule_symbols.size() == 1 && !right_rule_symbols.front().get_symbol()->is_token()) {
                can_bypass = true;
            }
        }
        Rule *rule = *_rules.insert(_rules.end(),
            new Rule(
                _rules.size(),
                node,
                is_start,
                left_rule_symbol,
                right_rule_symbols,
                explicit_follow,
                can_bypass
            )
        );
        _left_symbol_rules[left_symbol].push_back(rule);
    }

    // get all rules
    inline RuleVector const &get_rules() const
    {
        return _rules;
    }

    // get rules with left hand symbol
    RuleVector const &get_rules(Symbol const *left_symbol) const
    {
        SymbolRuleVectorMap::const_iterator p = _left_symbol_rules.find(left_symbol);
        assert(p != _left_symbol_rules.end());
        return p->second;
    }

    // true if left symbol
    bool is_left_symbol(Symbol const *symbol) const
    {
      return _left_symbol_rules.find(symbol) != _left_symbol_rules.end();
    }

    // freeze rules, no more
    void freeze_rules()
    {
        // make sure at least one start rule
        if (is_left_symbol(_c.get_start_symbol())) {
            throw std::runtime_error("missing at least one start rule");
        }
        // make sure each right hand nonterminal is defined
        for (SymbolRuleVectorMap::value_type const &p: _left_symbol_rules) {
            for (Rule const *rule: p.second) {
                for (RuleSymbol const &rule_symbol: rule->get_right_rule_symbols()) {
                    Symbol const *symbol = rule_symbol.get_symbol();
                    if (!symbol->is_token()) {
                        if (_c.is_start_symbol(symbol)) {
                            throw std::runtime_error("start symbol on right hand side of rule");
                        }
                        if (!is_left_symbol(symbol)) {
                            std::ostringstream ss;
                            ss << "nonterminal " << symbol->get_name() << " is not defined";
                            throw std::runtime_error(ss.str()); 
                        }
                    }
                }
            }
        }
    }

  private:
    Compiler &_c;
    bool _enable_bypass; // true if option to bypass rules is enabled
    RuleVector _rules; // all rules ordered by number
    typedef std::map<Symbol const *, RuleVector> SymbolRuleVectorMap;
    SymbolRuleVectorMap _left_symbol_rules; // rules indexed by left hand symbol
};

} // basilcc

#hdr
#include <basilcc_rule_symbol.h>
#include <vector>
#include <map>
#end

#src
#include <basilcc_compiler.h>
#include <basilcc_rule.h>
#include <basilcc_symbol.h>
#include <basilcc_util.h>
#include <cassert>
#include <sstream>
#end
